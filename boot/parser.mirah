# generated by mmeta on 2015-07-21T01:58:08Z
# do not modify, instead edit original .mmeta file

package mmeta

import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import mmeta.*


import java.util.*



class MMetaParser < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  def oneOf(chars:String)
    
          return _char(chars)
        
  end
  

  
  def fromTo(x:String, y:String)
    
    begin
      _start = _pos
      begin
        _p2 = _pos
        begin
          self.str(x)
          begin
            as1 = ArrayList.new
            begin
              while true do
                _li = Object(
                  begin
                    _p0 = _pos
                    begin
                      begin  # not
                        self.str(y)
                        nil
                      rescue RuleFailure
                        nil  # expected
                      else
                        raise @error
                      end
                      self._any()
                    rescue RuleFailure => ex
                      self._pos = _p0
                      raise ex
                    end
                  end
                )
                as1.add(_li)
              end
            rescue RuleFailure; end
            as1
          end
          self.str(y)
        rescue RuleFailure => ex
          self._pos = _p2
          raise ex
        end
      end
    rescue RuleFailure => ex
      ex.last = 'fromTo'
      raise ex
    end
  end
  

  
  def sp
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.sp")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            super()
          rescue RuleFailure
            begin
              self.fromTo("//", "\n")
            rescue RuleFailure
              begin
                self.fromTo("/*", "*/")
              rescue RuleFailure
                self.fromTo("#", "\n")
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.sp", _start, ex)
      else
        _t = _memoize("MMetaParser.sp", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'sp'
      raise ex
    end
  end
  

  
  def ws
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.ws")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            as3 = ArrayList.new
            begin
              while true do
                _li = Object(
                  begin
                    self.sp()
                  rescue RuleFailure
                    self.nl()
                  end
                )
                as3.add(_li)
              end
            rescue RuleFailure; end
            as3
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ws", _start, ex)
      else
        _t = _memoize("MMetaParser.ws", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ws'
      raise ex
    end
  end
  

  
  def listOf(e:String, s:String)
    
    begin
      _start = _pos; f = nil; rs = nil
      begin
        begin
          _p6 = _pos
          begin
            ws()
            f = (
              self.apply(e)
            )
            rs = (
              begin
                as5 = ArrayList.new
                begin
                  while true do
                    _li = Object(
                      begin
                        _p4 = _pos
                        begin
                          ws()
                          self.str(s)
                          ws()
                          self.apply(e)
                        rescue RuleFailure => ex
                          self._pos = _p4
                          raise ex
                        end
                      end
                    )
                    as5.add(_li)
                  end
                rescue RuleFailure; end
                as5
              end
            )
            concat([f], rs)
          rescue RuleFailure => ex
            self._pos = _p6
            raise ex
          end
        end
      rescue RuleFailure
        begin
          _p7 = _pos
          begin
            self.empty()
            ArrayList.new
          rescue RuleFailure => ex
            self._pos = _p7
            raise ex
          end
        end
      end
    rescue RuleFailure => ex
      ex.last = 'listOf'
      raise ex
    end
  end
  

  
  def nameFirst
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.nameFirst")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            if _string.startsWith("_", _pos)
              self._pos += 1
              "_"
            else
              raise @error
            end
          rescue RuleFailure
            self.letter()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.nameFirst", _start, ex)
      else
        _t = _memoize("MMetaParser.nameFirst", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'nameFirst'
      raise ex
    end
  end
  

  
  def nameRest
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.nameRest")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            self.nameFirst()
          rescue RuleFailure
            self.digit()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.nameRest", _start, ex)
      else
        _t = _memoize("MMetaParser.nameRest", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'nameRest'
      raise ex
    end
  end
  

  
  def name
    
    begin
      _start = _pos; f = nil; rs = nil
      _t = _sretrieve("MMetaParser.name")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p10 = _pos
            begin
              f = (
                self.nameFirst()
              )
              rs = (
                begin
                  as9 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.nameRest()
                      )
                      as9.add(_li)
                    end
                  rescue RuleFailure; end
                  as9
                end
              )
              begin
                 join(concat([f], rs)) 
              end
            rescue RuleFailure => ex
              self._pos = _p10
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.name", _start, ex)
      else
        _t = _memoize("MMetaParser.name", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'name'
      raise ex
    end
  end
  

  
  def rulename
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.rulename")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p11 = _pos
            begin
              begin  # not
                self.k("def")
                nil
              rescue RuleFailure
                nil  # expected
              else
                raise @error
              end
              begin  # not
                self.k("macro")
                nil
              rescue RuleFailure
                nil  # expected
              else
                raise @error
              end
              self.name()
            rescue RuleFailure => ex
              self._pos = _p11
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rulename", _start, ex)
      else
        _t = _memoize("MMetaParser.rulename", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rulename'
      raise ex
    end
  end
  

  
  def varname
    
    begin
      _start = _pos; p = nil; n = nil
      _t = _sretrieve("MMetaParser.varname")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p13 = _pos
            begin
              p = (
                begin
                  if _string.startsWith("@", _pos)
                    self._pos += 1
                    "@"
                  else
                    raise @error
                  end
                rescue RuleFailure
                  ""
                end
              )
              n = (
                self.name()
              )
              "#{p}#{n}"
            rescue RuleFailure => ex
              self._pos = _p13
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.varname", _start, ex)
      else
        _t = _memoize("MMetaParser.varname", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'varname'
      raise ex
    end
  end
  

  
  def hex
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.hex")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          self.oneOf("0123456789abcdefABCDEF")
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.hex", _start, ex)
      else
        _t = _memoize("MMetaParser.hex", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'hex'
      raise ex
    end
  end
  

  
  def echar
    
    begin
      _start = _pos; c = nil
      _t = _sretrieve("MMetaParser.echar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p16 = _pos
              begin
                if _string.startsWith("\\", _pos)
                  self._pos += 1
                  "\\"
                else
                  raise @error
                end
                begin
                  begin
                    _p15 = _pos
                    begin
                      c = (
                        self._any()
                      )
                      begin
                         "\\#{c}"; 
                      end
                    rescue RuleFailure => ex
                      self._pos = _p15
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p16
                raise ex
              end
            end
          rescue RuleFailure
            self._any()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.echar", _start, ex)
      else
        _t = _memoize("MMetaParser.echar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'echar'
      raise ex
    end
  end
  

  
  def tsString
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.tsString")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p22 = _pos
            begin
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              xs = (
                begin
                  as20 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p19 = _pos
                          begin
                            begin  # not
                              if _string.startsWith("\"", _pos)
                                self._pos += 1
                                "\""
                              else
                                raise @error
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            self.echar()
                          rescue RuleFailure => ex
                            self._pos = _p19
                            raise ex
                          end
                        end
                      )
                      as20.add(_li)
                    end
                  rescue RuleFailure; end
                  as20
                end
              )
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              begin
                 join(xs) 
              end
            rescue RuleFailure => ex
              self._pos = _p22
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.tsString", _start, ex)
      else
        _t = _memoize("MMetaParser.tsString", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'tsString'
      raise ex
    end
  end
  

  
  def dollar
    
    begin
      _start = _pos; xs = nil; n = nil
      _t = _sretrieve("MMetaParser.dollar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p26 = _pos
              begin
                if _string.startsWith("${", _pos)
                  self._pos += 2
                  "${"
                else
                  raise @error
                end
                xs = (
                  begin
                    as24 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.cbraces()
                        )
                        as24.add(_li)
                      end
                    rescue RuleFailure; end
                    as24
                  end
                )
                if _string.startsWith("}", _pos)
                  self._pos += 1
                  "}"
                else
                  raise @error
                end
                "\"+#{join(xs)}+\""
              rescue RuleFailure => ex
                self._pos = _p26
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p28 = _pos
              begin
                if _string.startsWith("$", _pos)
                  self._pos += 1
                  "$"
                else
                  raise @error
                end
                n = (
                  self.name()
                )
                "\"+#{n}+\""
              rescue RuleFailure => ex
                self._pos = _p28
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.dollar", _start, ex)
      else
        _t = _memoize("MMetaParser.dollar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'dollar'
      raise ex
    end
  end
  

  
  def dollarstring
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.dollarstring")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p34 = _pos
            begin
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              xs = (
                begin
                  as32 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p31 = _pos
                          begin
                            begin  # not
                              if _string.startsWith("\"", _pos)
                                self._pos += 1
                                "\""
                              else
                                raise @error
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            begin
                              self.dollar()
                            rescue RuleFailure
                              self.echar()
                            end
                          rescue RuleFailure => ex
                            self._pos = _p31
                            raise ex
                          end
                        end
                      )
                      as32.add(_li)
                    end
                  rescue RuleFailure; end
                  as32
                end
              )
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              begin
                 join(xs) 
              end
            rescue RuleFailure => ex
              self._pos = _p34
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.dollarstring", _start, ex)
      else
        _t = _memoize("MMetaParser.dollarstring", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'dollarstring'
      raise ex
    end
  end
  

  
  def string
    
    begin
      _start = _pos; s = nil
      _t = _sretrieve("MMetaParser.string")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p35 = _pos
            begin
              s = (
                self.tsString()
              )
              ["Str", s]
            rescue RuleFailure => ex
              self._pos = _p35
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.string", _start, ex)
      else
        _t = _memoize("MMetaParser.string", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'string'
      raise ex
    end
  end
  

  
  def number
    
    begin
      _start = _pos; sign = nil; ds = nil
      _t = _sretrieve("MMetaParser.number")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p39 = _pos
            begin
              sign = (
                begin
                  if _string.startsWith("-", _pos)
                    self._pos += 1
                    "-"
                  else
                    raise @error
                  end
                rescue RuleFailure
                  begin
                    if _string.startsWith("+", _pos)
                      self._pos += 1
                      "+"
                    else
                      raise @error
                    end
                  rescue RuleFailure
                    self.empty()
                  end
                end
              )
              ds = (
                begin
                  as38 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.digit()
                      )
                      as38.add(_li)
                    end
                  rescue RuleFailure; end
                  raise @error if as38.size == 0
                  as38
                end
              )
              ["HLit", "#{sign}#{join(ds)}"]
            rescue RuleFailure => ex
              self._pos = _p39
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.number", _start, ex)
      else
        _t = _memoize("MMetaParser.number", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'number'
      raise ex
    end
  end
  

  
  def symbol
    
    begin
      _start = _pos; s = nil; c = nil
      _t = _sretrieve("MMetaParser.symbol")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p48 = _pos
            begin
              begin
                if _string.startsWith("'", _pos)
                  self._pos += 1
                  "'"
                else
                  raise @error
                end
              rescue RuleFailure
                if _string.startsWith(":", _pos)
                  self._pos += 1
                  ":"
                else
                  raise @error
                end
              end
              begin
                s = (
                  self.name()
                )
              rescue RuleFailure
                begin
                  _p47 = _pos
                  begin
                    if _string.startsWith("'", _pos)
                      self._pos += 1
                      "'"
                    else
                      raise @error
                    end
                    c = (
                      begin
                        as45 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p44 = _pos
                                begin
                                  begin  # not
                                    if _string.startsWith("'", _pos)
                                      self._pos += 1
                                      "'"
                                    else
                                      raise @error
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p44
                                  raise ex
                                end
                              end
                            )
                            as45.add(_li)
                          end
                        rescue RuleFailure; end
                        raise @error if as45.size == 0
                        as45
                      end
                    )
                    if _string.startsWith("'", _pos)
                      self._pos += 1
                      "'"
                    else
                      raise @error
                    end
                    s = (
                      begin
                        join(c)
                      end
                    )
                  rescue RuleFailure => ex
                    self._pos = _p47
                    raise ex
                  end
                end
              end
              ["Sym", s]
            rescue RuleFailure => ex
              self._pos = _p48
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.symbol", _start, ex)
      else
        _t = _memoize("MMetaParser.symbol", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'symbol'
      raise ex
    end
  end
  

  
  def k(keyword:String)
    
    begin
      _start = _pos
      begin
        _p49 = _pos
        begin
          self.str(keyword)
          begin  # not
            begin
              self.nameFirst()
            rescue RuleFailure
              self.digit()
            end
            nil
          rescue RuleFailure
            nil  # expected
          else
            raise @error
          end
          keyword
        rescue RuleFailure => ex
          self._pos = _p49
          raise ex
        end
      end
    rescue RuleFailure => ex
      ex.last = 'k'
      raise ex
    end
  end
  

  
  def error
    
    begin
      _start = _pos; msg = nil; b = nil
      _t = _sretrieve("MMetaParser.error")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p51 = _pos
            begin
              ws()
              if _string.startsWith("!", _pos)
                self._pos += 1
                "!"
              else
                raise @error
              end
              msg = (
                begin
                  self.dollarstring()
                rescue RuleFailure
                  self.empty()
                end
              )
              b = (
                self.expr4()
              )
              ["Error", msg, b]
            rescue RuleFailure => ex
              self._pos = _p51
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.error", _start, ex)
      else
        _t = _memoize("MMetaParser.error", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'error'
      raise ex
    end
  end
  

  
  def any
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.any")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p53 = _pos
            begin
              if _string.startsWith("_", _pos)
                self._pos += 1
                "_"
              else
                raise @error
              end
              ["App", "_any"]
            rescue RuleFailure => ex
              self._pos = _p53
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.any", _start, ex)
      else
        _t = _memoize("MMetaParser.any", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'any'
      raise ex
    end
  end
  

  
  def wsdot
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.wsdot")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p55 = _pos
            begin
              if _string.startsWith(".", _pos)
                self._pos += 1
                "."
              else
                raise @error
              end
              ["Dot"]
            rescue RuleFailure => ex
              self._pos = _p55
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.wsdot", _start, ex)
      else
        _t = _memoize("MMetaParser.wsdot", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'wsdot'
      raise ex
    end
  end
  

  
  def args
    
    begin
      _start = _pos; as = nil
      _t = _sretrieve("MMetaParser.args")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p59 = _pos
              begin
                if _string.startsWith("(", _pos)
                  self._pos += 1
                  "("
                else
                  raise @error
                end
                begin
                  begin
                    _p58 = _pos
                    begin
                      as = (
                        self.listOf("simplehost", ",")
                      )
                      ws()
                      if _string.startsWith(")", _pos)
                        self._pos += 1
                        ")"
                      else
                        raise @error
                      end
                      as
                    rescue RuleFailure => ex
                      self._pos = _p58
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p59
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p60 = _pos
              begin
                self.empty()
                ArrayList.new
              rescue RuleFailure => ex
                self._pos = _p60
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.args", _start, ex)
      else
        _t = _memoize("MMetaParser.args", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'args'
      raise ex
    end
  end
  

  
  def application
    
    begin
      _start = _pos; r = nil; as = nil
      _t = _sretrieve("MMetaParser.application")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p63 = _pos
              begin
                if _string.startsWith("super.", _pos)
                  self._pos += 6
                  "super."
                else
                  raise @error
                end
                begin
                  begin
                    _p62 = _pos
                    begin
                      r = (
                        self.name()
                      )
                      as = (
                        self.args()
                      )
                      concat(["App", "super", r], as)
                    rescue RuleFailure => ex
                      self._pos = _p62
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p63
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p64 = _pos
              begin
                r = (
                  self.name()
                )
                as = (
                  self.args()
                )
                concat(["App", r], as)
              rescue RuleFailure => ex
                self._pos = _p64
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.application", _start, ex)
      else
        _t = _memoize("MMetaParser.application", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'application'
      raise ex
    end
  end
  

  
  def fname
    
    begin
      _start = _pos; x = nil; t = nil; n = nil
      _t = _sretrieve("MMetaParser.fname")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p68 = _pos
            begin
              t = (
                begin
                  as67 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p66 = _pos
                          begin
                            x = (
                              self.name()
                            )
                            if _string.startsWith(".", _pos)
                              self._pos += 1
                              "."
                            else
                              raise @error
                            end
                            "#{x}."
                          rescue RuleFailure => ex
                            self._pos = _p66
                            raise ex
                          end
                        end
                      )
                      as67.add(_li)
                    end
                  rescue RuleFailure; end
                  as67
                end
              )
              n = (
                self.name()
              )
              "#{join(t)}#{n}"
            rescue RuleFailure => ex
              self._pos = _p68
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.fname", _start, ex)
      else
        _t = _memoize("MMetaParser.fname", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'fname'
      raise ex
    end
  end
  

  
  def parens
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaParser.parens")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p73 = _pos
            begin
              if _string.startsWith("(", _pos)
                self._pos += 1
                "("
              else
                raise @error
              end
              x = (
                begin
                  as71 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          self.parens()
                        rescue RuleFailure
                          begin
                            _p70 = _pos
                            begin
                              begin  # not
                                self.oneOf("()")
                                nil
                              rescue RuleFailure
                                nil  # expected
                              else
                                raise @error
                              end
                              self._any()
                            rescue RuleFailure => ex
                              self._pos = _p70
                              raise ex
                            end
                          end
                        end
                      )
                      as71.add(_li)
                    end
                  rescue RuleFailure; end
                  as71
                end
              )
              if _string.startsWith(")", _pos)
                self._pos += 1
                ")"
              else
                raise @error
              end
              "(#{join(x)})"
            rescue RuleFailure => ex
              self._pos = _p73
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.parens", _start, ex)
      else
        _t = _memoize("MMetaParser.parens", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'parens'
      raise ex
    end
  end
  

  
  def dotted_name
    
    begin
      _start = _pos; h = nil; t = nil; l = nil
      _t = _sretrieve("MMetaParser.dotted_name")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p77 = _pos
            begin
              ws()
              h = (
                self.name()
              )
              t = (
                begin
                  as76 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p75 = _pos
                          begin
                            ws()
                            if _string.startsWith(".", _pos)
                              self._pos += 1
                              "."
                            else
                              raise @error
                            end
                            ws()
                            self.name()
                          rescue RuleFailure => ex
                            self._pos = _p75
                            raise ex
                          end
                        end
                      )
                      as76.add(_li)
                    end
                  rescue RuleFailure; end
                  as76
                end
              )
              l = (
                concat([h], t)
              )
              begin
                 join(l, ".") 
              end
            rescue RuleFailure => ex
              self._pos = _p77
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.dotted_name", _start, ex)
      else
        _t = _memoize("MMetaParser.dotted_name", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'dotted_name'
      raise ex
    end
  end
  

  
  def rewrite_expr
    
    begin
      _start = _pos; n = nil; p = nil; c = nil; cl = nil; s = nil; xs = nil
      _t = _sretrieve("MMetaParser.rewrite_expr")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p78 = _pos
              begin
                ws()
                n = (
                  self.dotted_name()
                )
                p = (
                  self.parens()
                )
                ["HLit", "#{n}#{p}"]
              rescue RuleFailure => ex
                self._pos = _p78
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p81 = _pos
                begin
                  ws()
                  if _string.startsWith("^(", _pos)
                    self._pos += 2
                    "^("
                  else
                    raise @error
                  end
                  ws()
                  n = (
                    self.name()
                  )
                  c = (
                    self.rewrite_expr()
                  )
                  ws()
                  self.oneOf("*+")
                  ws()
                  if _string.startsWith(")", _pos)
                    self._pos += 1
                    ")"
                  else
                    raise @error
                  end
                  ["Node", n, ["HList", c]]
                rescue RuleFailure => ex
                  self._pos = _p81
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                begin
                  _p86 = _pos
                  begin
                    ws()
                    if _string.startsWith("^(", _pos)
                      self._pos += 2
                      "^("
                    else
                      raise @error
                    end
                    ws()
                    n = (
                      self.name()
                    )
                    begin
                      begin
                        _p85 = _pos
                        begin
                          cl = (
                            begin
                              as83 = ArrayList.new
                              begin
                                while true do
                                  _li = Object(
                                    self.rewrite_expr()
                                  )
                                  as83.add(_li)
                                end
                              rescue RuleFailure; end
                              as83
                            end
                          )
                          ws()
                          if _string.startsWith(")", _pos)
                            self._pos += 1
                            ")"
                          else
                            raise @error
                          end
                          ["Node", n, concat(["HList"], cl)]
                        rescue RuleFailure => ex
                          self._pos = _p85
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p86
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p88 = _pos
                    begin
                      ws()
                      if _string.startsWith("$", _pos)
                        self._pos += 1
                        "$"
                      else
                        raise @error
                      end
                      n = (
                        self.name()
                      )
                      ["TLit", n]
                    rescue RuleFailure => ex
                      self._pos = _p88
                      raise ex
                    end
                  end
                rescue RuleFailure
                  begin
                    begin
                      _p89 = _pos
                      begin
                        ws()
                        s = (
                          self.tsString()
                        )
                        ["HStr", s]
                      rescue RuleFailure => ex
                        self._pos = _p89
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    begin
                      begin
                        _p90 = _pos
                        begin
                          ws()
                          n = (
                            self.dotted_name()
                          )
                          ["HLit", n]
                        rescue RuleFailure => ex
                          self._pos = _p90
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      begin
                        _p94 = _pos
                        begin
                          ws()
                          if _string.startsWith("[", _pos)
                            self._pos += 1
                            "["
                          else
                            raise @error
                          end
                          begin
                            begin
                              _p93 = _pos
                              begin
                                xs = (
                                  self.listOf("rewrite_expr", ",")
                                )
                                ws()
                                if _string.startsWith("]", _pos)
                                  self._pos += 1
                                  "]"
                                else
                                  raise @error
                                end
                                concat(["HList"], xs)
                              rescue RuleFailure => ex
                                self._pos = _p93
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            raise SyntaxError.new("", @error.last, _pos, _string, _list)
                          end
                        rescue RuleFailure => ex
                          self._pos = _p94
                          raise ex
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rewrite_expr", _start, ex)
      else
        _t = _memoize("MMetaParser.rewrite_expr", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rewrite_expr'
      raise ex
    end
  end
  

  
  def simplehost
    
    begin
      _start = _pos; rs = nil; ls = nil; x = nil
      _t = _sretrieve("MMetaParser.simplehost")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p96 = _pos
              begin
                rs = (
                  self.simplehost1()
                )
                ws()
                if _string.startsWith("+", _pos)
                  self._pos += 1
                  "+"
                else
                  raise @error
                end
                ws()
                ls = (
                  self.simplehost()
                )
                ["HConcat", rs, ls]
              rescue RuleFailure => ex
                self._pos = _p96
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p97 = _pos
              begin
                x = (
                  self.simplehost1()
                )
                x
              rescue RuleFailure => ex
                self._pos = _p97
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.simplehost", _start, ex)
      else
        _t = _memoize("MMetaParser.simplehost", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'simplehost'
      raise ex
    end
  end
  

  
  def simplehost1
    
    begin
      _start = _pos; xs = nil; num = nil; s = nil; n = nil
      _t = _sretrieve("MMetaParser.simplehost1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p100 = _pos
              begin
                if _string.startsWith("[", _pos)
                  self._pos += 1
                  "["
                else
                  raise @error
                end
                xs = (
                  self.listOf("simplehost", ",")
                )
                ws()
                if _string.startsWith("]", _pos)
                  self._pos += 1
                  "]"
                else
                  raise @error
                end
                concat(["HList"], xs)
              rescue RuleFailure => ex
                self._pos = _p100
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p101 = _pos
                begin
                  ws()
                  num = (
                    self.number()
                  )
                  num
                rescue RuleFailure => ex
                  self._pos = _p101
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                begin
                  _p104 = _pos
                  begin
                    ws()
                    begin
                      if _string.startsWith("'", _pos)
                        self._pos += 1
                        "'"
                      else
                        raise @error
                      end
                    rescue RuleFailure
                      if _string.startsWith(":", _pos)
                        self._pos += 1
                        ":"
                      else
                        raise @error
                      end
                    end
                    s = (
                      self.name()
                    )
                    ["HStr", s]
                  rescue RuleFailure => ex
                    self._pos = _p104
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p105 = _pos
                    begin
                      ws()
                      s = (
                        self.tsString()
                      )
                      ["HStr", s]
                    rescue RuleFailure => ex
                      self._pos = _p105
                      raise ex
                    end
                  end
                rescue RuleFailure
                  begin
                    begin
                      _p107 = _pos
                      begin
                        ws()
                        if _string.startsWith("@", _pos)
                          self._pos += 1
                          "@"
                        else
                          raise @error
                        end
                        n = (
                          self.name()
                        )
                        ["HLit", "@#{n}"]
                      rescue RuleFailure => ex
                        self._pos = _p107
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    begin
                      _p108 = _pos
                      begin
                        ws()
                        n = (
                          self.name()
                        )
                        ["HLit", n]
                      rescue RuleFailure => ex
                        self._pos = _p108
                        raise ex
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.simplehost1", _start, ex)
      else
        _t = _memoize("MMetaParser.simplehost1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'simplehost1'
      raise ex
    end
  end
  

  
  def cbraces
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.cbraces")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p112 = _pos
              begin
                if _string.startsWith("{", _pos)
                  self._pos += 1
                  "{"
                else
                  raise @error
                end
                xs = (
                  begin
                    as110 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.cbraces()
                        )
                        as110.add(_li)
                      end
                    rescue RuleFailure; end
                    as110
                  end
                )
                if _string.startsWith("}", _pos)
                  self._pos += 1
                  "}"
                else
                  raise @error
                end
                begin
                   "{"+ join(xs) +"}" 
                end
              rescue RuleFailure => ex
                self._pos = _p112
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p114 = _pos
              begin
                begin  # not
                  if _string.startsWith("}", _pos)
                    self._pos += 1
                    "}"
                  else
                    raise @error
                  end
                  nil
                rescue RuleFailure
                  nil  # expected
                else
                  raise @error
                end
                self._any()
              rescue RuleFailure => ex
                self._pos = _p114
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.cbraces", _start, ex)
      else
        _t = _memoize("MMetaParser.cbraces", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'cbraces'
      raise ex
    end
  end
  

  
  def semAction
    
    begin
      _start = _pos; s = nil; xs = nil
      _t = _sretrieve("MMetaParser.semAction")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p117 = _pos
              begin
                if _string.startsWith("{", _pos)
                  self._pos += 1
                  "{"
                else
                  raise @error
                end
                ws()
                s = (
                  self.simplehost()
                )
                ws()
                if _string.startsWith("}", _pos)
                  self._pos += 1
                  "}"
                else
                  raise @error
                end
                ["SAct", s]
              rescue RuleFailure => ex
                self._pos = _p117
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p122 = _pos
                begin
                  if _string.startsWith("{", _pos)
                    self._pos += 1
                    "{"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p121 = _pos
                      begin
                        xs = (
                          begin
                            as119 = ArrayList.new
                            begin
                              while true do
                                _li = Object(
                                  self.cbraces()
                                )
                                as119.add(_li)
                              end
                            rescue RuleFailure; end
                            as119
                          end
                        )
                        if _string.startsWith("}", _pos)
                          self._pos += 1
                          "}"
                        else
                          raise @error
                        end
                        ["Act", "#{join(xs)}"]
                      rescue RuleFailure => ex
                        self._pos = _p121
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p122
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                _p125 = _pos
                begin
                  if _string.startsWith("->", _pos)
                    self._pos += 2
                    "->"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p124 = _pos
                      begin
                        s = (
                          self.rewrite_expr()
                        )
                        ["SAct", s]
                      rescue RuleFailure => ex
                        self._pos = _p124
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p125
                  raise ex
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.semAction", _start, ex)
      else
        _t = _memoize("MMetaParser.semAction", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'semAction'
      raise ex
    end
  end
  

  
  def semPred
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.semPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p130 = _pos
            begin
              if _string.startsWith("?{", _pos)
                self._pos += 2
                "?{"
              else
                raise @error
              end
              begin
                begin
                  _p129 = _pos
                  begin
                    xs = (
                      begin
                        as127 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.cbraces()
                            )
                            as127.add(_li)
                          end
                        rescue RuleFailure; end
                        as127
                      end
                    )
                    if _string.startsWith("}", _pos)
                      self._pos += 1
                      "}"
                    else
                      raise @error
                    end
                    ["Pred", "#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p129
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p130
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.semPred", _start, ex)
      else
        _t = _memoize("MMetaParser.semPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'semPred'
      raise ex
    end
  end
  

  
  def synPred
    
    begin
      _start = _pos; p = nil; e = nil; t = nil
      _t = _sretrieve("MMetaParser.synPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p135 = _pos
            begin
              ws()
              if _string.startsWith("(", _pos)
                self._pos += 1
                "("
              else
                raise @error
              end
              p = (
                self.expr()
              )
              ws()
              if _string.startsWith(")", _pos)
                self._pos += 1
                ")"
              else
                raise @error
              end
              ws()
              if _string.startsWith("=>", _pos)
                self._pos += 2
                "=>"
              else
                raise @error
              end
              e = (
                self.expr4()
              )
              begin
                begin
                  _p134 = _pos
                  begin
                    t = (
                      self.synPredTail()
                    )
                    ["SynPred", ["Peek", p], e, t]
                  rescue RuleFailure => ex
                    self._pos = _p134
                    raise ex
                  end
                end
              rescue RuleFailure
                ["SynPred", ["Peek", p], e]
              end
            rescue RuleFailure => ex
              self._pos = _p135
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.synPred", _start, ex)
      else
        _t = _memoize("MMetaParser.synPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'synPred'
      raise ex
    end
  end
  

  
  def synPredTail
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.synPredTail")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p137 = _pos
            begin
              ws()
              if _string.startsWith("|", _pos)
                self._pos += 1
                "|"
              else
                raise @error
              end
              begin
                self.synPred()
              rescue RuleFailure
                self.expr4()
              end
            rescue RuleFailure => ex
              self._pos = _p137
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.synPredTail", _start, ex)
      else
        _t = _memoize("MMetaParser.synPredTail", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'synPredTail'
      raise ex
    end
  end
  

  
  def token
    
    begin
      _start = _pos; n = nil
      _t = _sretrieve("MMetaParser.token")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p139 = _pos
            begin
              if _string.startsWith("$", _pos)
                self._pos += 1
                "$"
              else
                raise @error
              end
              n = (
                self.name()
              )
              n
            rescue RuleFailure => ex
              self._pos = _p139
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.token", _start, ex)
      else
        _t = _memoize("MMetaParser.token", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'token'
      raise ex
    end
  end
  

  
  def tokens
    
    begin
      _start = _pos; a = nil; b = nil
      _t = _sretrieve("MMetaParser.tokens")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p142 = _pos
            begin
              a = (
                self.token()
              )
              begin
                begin
                  _p141 = _pos
                  begin
                    ws()
                    if _string.startsWith("..", _pos)
                      self._pos += 2
                      ".."
                    else
                      raise @error
                    end
                    ws()
                    b = (
                      self.token()
                    )
                    ["TokenRange", a, b]
                  rescue RuleFailure => ex
                    self._pos = _p141
                    raise ex
                  end
                end
              rescue RuleFailure
                ["AToken", a]
              end
            rescue RuleFailure => ex
              self._pos = _p142
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.tokens", _start, ex)
      else
        _t = _memoize("MMetaParser.tokens", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'tokens'
      raise ex
    end
  end
  

  
  def expr
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.expr")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p143 = _pos
            begin
              xs = (
                self.listOf("expr4", "|")
              )
              concat(["Or"], xs)
            rescue RuleFailure => ex
              self._pos = _p143
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr", _start, ex)
      else
        _t = _memoize("MMetaParser.expr", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr'
      raise ex
    end
  end
  

  
  def expr4
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.expr4")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p145 = _pos
            begin
              xs = (
                begin
                  as144 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          self.error()
                        rescue RuleFailure
                          self.expr3()
                        end
                      )
                      as144.add(_li)
                    end
                  rescue RuleFailure; end
                  as144
                end
              )
              concat(["And"], xs)
            rescue RuleFailure => ex
              self._pos = _p145
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr4", _start, ex)
      else
        _t = _memoize("MMetaParser.expr4", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr4'
      raise ex
    end
  end
  

  
  def optIter(x:Object)
    
    begin
      _start = _pos
      begin
        begin
          _p147 = _pos
          begin
            if _string.startsWith("*", _pos)
              self._pos += 1
              "*"
            else
              raise @error
            end
            ["Many", x]
          rescue RuleFailure => ex
            self._pos = _p147
            raise ex
          end
        end
      rescue RuleFailure
        begin
          begin
            _p149 = _pos
            begin
              if _string.startsWith("+", _pos)
                self._pos += 1
                "+"
              else
                raise @error
              end
              ["Many1", x]
            rescue RuleFailure => ex
              self._pos = _p149
              raise ex
            end
          end
        rescue RuleFailure
          begin
            begin
              _p151 = _pos
              begin
                if _string.startsWith("?", _pos)
                  self._pos += 1
                  "?"
                else
                  raise @error
                end
                ["Opt", x]
              rescue RuleFailure => ex
                self._pos = _p151
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p152 = _pos
              begin
                self.empty()
                x
              rescue RuleFailure => ex
                self._pos = _p152
                raise ex
              end
            end
          end
        end
      end
    rescue RuleFailure => ex
      ex.last = 'optIter'
      raise ex
    end
  end
  

  
  def expr3
    
    begin
      _start = _pos; n = nil; e = nil; x = nil
      _t = _sretrieve("MMetaParser.expr3")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p155 = _pos
              begin
                ws()
                n = (
                  self.name()
                )
                ws()
                if _string.startsWith("=", _pos)
                  self._pos += 1
                  "="
                else
                  raise @error
                end
                begin
                  begin
                    _p154 = _pos
                    begin
                      ws()
                      e = (
                        self.expr2()
                      )
                      x = (
                        self.optIter(e)
                      )
                      ["Set", n, x]
                    rescue RuleFailure => ex
                      self._pos = _p154
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p155
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p156 = _pos
              begin
                ws()
                e = (
                  self.expr2()
                )
                x = (
                  self.optIter(e)
                )
                x
              rescue RuleFailure => ex
                self._pos = _p156
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr3", _start, ex)
      else
        _t = _memoize("MMetaParser.expr3", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr3'
      raise ex
    end
  end
  

  
  def expr2
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaParser.expr2")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p159 = _pos
              begin
                if _string.startsWith("~", _pos)
                  self._pos += 1
                  "~"
                else
                  raise @error
                end
                begin
                  begin
                    _p158 = _pos
                    begin
                      x = (
                        self.expr2()
                      )
                      ["Not", x]
                    rescue RuleFailure => ex
                      self._pos = _p158
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p159
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p162 = _pos
                begin
                  if _string.startsWith("&", _pos)
                    self._pos += 1
                    "&"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p161 = _pos
                      begin
                        x = (
                          self.expr1()
                        )
                        ["Peek", x]
                      rescue RuleFailure => ex
                        self._pos = _p161
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p162
                  raise ex
                end
              end
            rescue RuleFailure
              self.expr1()
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr2", _start, ex)
      else
        _t = _memoize("MMetaParser.expr2", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr2'
      raise ex
    end
  end
  

  
  def expr1
    
    begin
      _start = _pos; k = nil; x = nil
      _t = _sretrieve("MMetaParser.expr1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            self.wsdot()
          rescue RuleFailure
            begin
              self.any()
            rescue RuleFailure
              begin
                self.semPred()
              rescue RuleFailure
                begin
                  self.semAction()
                rescue RuleFailure
                  begin
                    self.application()
                  rescue RuleFailure
                    begin
                      self.tokens()
                    rescue RuleFailure
                      begin
                        begin
                          _p163 = _pos
                          begin
                            k = (
                              begin
                                self.k("null")
                              rescue RuleFailure
                                begin
                                  self.k("true")
                                rescue RuleFailure
                                  self.k("false")
                                end
                              end
                            )
                            ["HLit", k]
                          rescue RuleFailure => ex
                            self._pos = _p163
                            raise ex
                          end
                        end
                      rescue RuleFailure
                        begin
                          self.string()
                        rescue RuleFailure
                          begin
                            self.symbol()
                          rescue RuleFailure
                            begin
                              self.number()
                            rescue RuleFailure
                              begin
                                begin
                                  _p167 = _pos
                                  begin
                                    if _string.startsWith("[", _pos)
                                      self._pos += 1
                                      "["
                                    else
                                      raise @error
                                    end
                                    begin
                                      begin
                                        _p166 = _pos
                                        begin
                                          ws()
                                          x = (
                                            self.expr()
                                          )
                                          ws()
                                          if _string.startsWith("]", _pos)
                                            self._pos += 1
                                            "]"
                                          else
                                            raise @error
                                          end
                                          ["List", x]
                                        rescue RuleFailure => ex
                                          self._pos = _p166
                                          raise ex
                                        end
                                      end
                                    rescue RuleFailure
                                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                                    end
                                  rescue RuleFailure => ex
                                    self._pos = _p167
                                    raise ex
                                  end
                                end
                              rescue RuleFailure
                                begin
                                  self.synPred()
                                rescue RuleFailure
                                  begin
                                    _p171 = _pos
                                    begin
                                      if _string.startsWith("(", _pos)
                                        self._pos += 1
                                        "("
                                      else
                                        raise @error
                                      end
                                      begin
                                        begin
                                          _p170 = _pos
                                          begin
                                            ws()
                                            x = (
                                              self.expr()
                                            )
                                            ws()
                                            if _string.startsWith(")", _pos)
                                              self._pos += 1
                                              ")"
                                            else
                                              raise @error
                                            end
                                            x
                                          rescue RuleFailure => ex
                                            self._pos = _p170
                                            raise ex
                                          end
                                        end
                                      rescue RuleFailure
                                        raise SyntaxError.new("", @error.last, _pos, _string, _list)
                                      end
                                    rescue RuleFailure => ex
                                      self._pos = _p171
                                      raise ex
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr1", _start, ex)
      else
        _t = _memoize("MMetaParser.expr1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr1'
      raise ex
    end
  end
  

  
  def annotation
    
    begin
      _start = _pos; t = nil; l = nil; n = nil
      _t = _sretrieve("MMetaParser.annotation")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p176 = _pos
              begin
                ws()
                if _string.startsWith("$Memo", _pos)
                  self._pos += 5
                  "$Memo"
                else
                  raise @error
                end
                begin  # optional
                  begin
                    _p175 = _pos
                    begin
                      ws()
                      if _string.startsWith("[", _pos)
                        self._pos += 1
                        "["
                      else
                        raise @error
                      end
                      ws()
                      t = (
                        self.name()
                      )
                      ws()
                      if _string.startsWith("]", _pos)
                        self._pos += 1
                        "]"
                      else
                        raise @error
                      end
                    rescue RuleFailure => ex
                      self._pos = _p175
                      raise ex
                    end
                  end
                rescue RuleFailure
                  nil
                end
                ["Memo", t]
              rescue RuleFailure => ex
                self._pos = _p176
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p181 = _pos
                begin
                  ws()
                  if _string.startsWith("$Scope", _pos)
                    self._pos += 6
                    "$Scope"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p180 = _pos
                      begin
                        ws()
                        if _string.startsWith("[", _pos)
                          self._pos += 1
                          "["
                        else
                          raise @error
                        end
                        ws()
                        l = (
                          self.listOf("varname", ",")
                        )
                        ws()
                        if _string.startsWith("]", _pos)
                          self._pos += 1
                          "]"
                        else
                          raise @error
                        end
                        ["Scope", l]
                      rescue RuleFailure => ex
                        self._pos = _p180
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p181
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                _p186 = _pos
                begin
                  ws()
                  if _string.startsWith("$Returns", _pos)
                    self._pos += 8
                    "$Returns"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p185 = _pos
                      begin
                        ws()
                        if _string.startsWith("[", _pos)
                          self._pos += 1
                          "["
                        else
                          raise @error
                        end
                        ws()
                        n = (
                          self.varname()
                        )
                        ws()
                        if _string.startsWith("]", _pos)
                          self._pos += 1
                          "]"
                        else
                          raise @error
                        end
                        ["Returns", n]
                      rescue RuleFailure => ex
                        self._pos = _p185
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p186
                  raise ex
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.annotation", _start, ex)
      else
        _t = _memoize("MMetaParser.annotation", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'annotation'
      raise ex
    end
  end
  

  
  def ruleArgs
    
    begin
      _start = _pos; s = nil
      _t = _sretrieve("MMetaParser.ruleArgs")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p192 = _pos
            begin
              ws()
              if _string.startsWith("(", _pos)
                self._pos += 1
                "("
              else
                raise @error
              end
              s = (
                begin
                  as190 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p189 = _pos
                          begin
                            begin  # not
                              if _string.startsWith(")", _pos)
                                self._pos += 1
                                ")"
                              else
                                raise @error
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            self._any()
                          rescue RuleFailure => ex
                            self._pos = _p189
                            raise ex
                          end
                        end
                      )
                      as190.add(_li)
                    end
                  rescue RuleFailure; end
                  as190
                end
              )
              if _string.startsWith(")", _pos)
                self._pos += 1
                ")"
              else
                raise @error
              end
              "(#{join(s)})"
            rescue RuleFailure => ex
              self._pos = _p192
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ruleArgs", _start, ex)
      else
        _t = _memoize("MMetaParser.ruleArgs", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ruleArgs'
      raise ex
    end
  end
  

  
  def rule
    
    begin
      _start = _pos; a = nil; n = nil; args = nil; x = nil
      _t = _sretrieve("MMetaParser.rule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p197 = _pos
            begin
              a = (
                begin
                  as193 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.annotation()
                      )
                      as193.add(_li)
                    end
                  rescue RuleFailure; end
                  as193
                end
              )
              ws()
              n = (
                self.rulename()
              )
              begin
                begin
                  _p196 = _pos
                  begin
                    args = (
                      begin  # optional
                        self.ruleArgs()
                      rescue RuleFailure
                        nil
                      end
                    )
                    ws()
                    if _string.startsWith(":", _pos)
                      self._pos += 1
                      ":"
                    else
                      raise @error
                    end
                    ws()
                    x = (
                      self.expr()
                    )
                    ws()
                    if _string.startsWith(";", _pos)
                      self._pos += 1
                      ";"
                    else
                      raise @error
                    end
                    ["Rule", n, args, x, a]
                  rescue RuleFailure => ex
                    self._pos = _p196
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p197
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rule", _start, ex)
      else
        _t = _memoize("MMetaParser.rule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rule'
      raise ex
    end
  end
  

  
  def qualifiers
    
    begin
      _start = _pos; qs = nil
      _t = _sretrieve("MMetaParser.qualifiers")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p204 = _pos
            begin
              qs = (
                begin
                  as203 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          begin
                            _p198 = _pos
                            begin
                              ws()
                              self.k("public")
                            rescue RuleFailure => ex
                              self._pos = _p198
                              raise ex
                            end
                          end
                        rescue RuleFailure
                          begin
                            begin
                              _p199 = _pos
                              begin
                                ws()
                                self.k("private")
                              rescue RuleFailure => ex
                                self._pos = _p199
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            begin
                              begin
                                _p200 = _pos
                                begin
                                  ws()
                                  self.k("final")
                                rescue RuleFailure => ex
                                  self._pos = _p200
                                  raise ex
                                end
                              end
                            rescue RuleFailure
                              begin
                                begin
                                  _p201 = _pos
                                  begin
                                    ws()
                                    self.k("static")
                                  rescue RuleFailure => ex
                                    self._pos = _p201
                                    raise ex
                                  end
                                end
                              rescue RuleFailure
                                begin
                                  _p202 = _pos
                                  begin
                                    ws()
                                    self.k("abstract")
                                  rescue RuleFailure => ex
                                    self._pos = _p202
                                    raise ex
                                  end
                                end
                              end
                            end
                          end
                        end
                      )
                      as203.add(_li)
                    end
                  rescue RuleFailure; end
                  raise @error if as203.size == 0
                  as203
                end
              )
              begin
                
                        join(qs, " ")
                    
              end
            rescue RuleFailure => ex
              self._pos = _p204
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.qualifiers", _start, ex)
      else
        _t = _memoize("MMetaParser.qualifiers", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'qualifiers'
      raise ex
    end
  end
  

  
  def method
    
    begin
      _start = _pos; m = nil; s = nil; n = nil; as = nil; returntypeopt = nil; bs = nil
      _t = _sretrieve("MMetaParser.method")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p222 = _pos
            begin
              m = (
                begin  # optional
                  begin
                    _p205 = _pos
                    begin
                      self.k("macro")
                      ws()
                    rescue RuleFailure => ex
                      self._pos = _p205
                      raise ex
                    end
                  end
                rescue RuleFailure
                  nil
                end
              )
              self.k("def")
              ws()
              s = (
                begin
                  if _string.startsWith("self.", _pos)
                    self._pos += 5
                    "self."
                  else
                    raise @error
                  end
                rescue RuleFailure
                  ""
                end
              )
              begin
                begin
                  _p221 = _pos
                  begin
                    n = (
                      self.name()
                    )
                    begin
                      begin
                        _p220 = _pos
                        begin
                          begin
                            begin
                              _p215 = _pos
                              begin
                                ws()
                                if _string.startsWith("(", _pos)
                                  self._pos += 1
                                  "("
                                else
                                  raise @error
                                end
                                as = (
                                  begin
                                    as210 = ArrayList.new
                                    begin
                                      while true do
                                        _li = Object(
                                          begin
                                            _p209 = _pos
                                            begin
                                              begin  # not
                                                if _string.startsWith(")", _pos)
                                                  self._pos += 1
                                                  ")"
                                                else
                                                  raise @error
                                                end
                                                nil
                                              rescue RuleFailure
                                                nil  # expected
                                              else
                                                raise @error
                                              end
                                              self._any()
                                            rescue RuleFailure => ex
                                              self._pos = _p209
                                              raise ex
                                            end
                                          end
                                        )
                                        as210.add(_li)
                                      end
                                    rescue RuleFailure; end
                                    as210
                                  end
                                )
                                if _string.startsWith(")", _pos)
                                  self._pos += 1
                                  ")"
                                else
                                  raise @error
                                end
                                begin  # optional
                                  begin
                                    _p214 = _pos
                                    begin
                                      returntypeopt = (
                                        begin
                                          _p213 = _pos
                                          begin
                                            if _string.startsWith(":", _pos)
                                              self._pos += 1
                                              ":"
                                            else
                                              raise @error
                                            end
                                            self.name()
                                          rescue RuleFailure => ex
                                            self._pos = _p213
                                            raise ex
                                          end
                                        end
                                      )
                                    rescue RuleFailure => ex
                                      self._pos = _p214
                                      raise ex
                                    end
                                  end
                                rescue RuleFailure
                                  nil
                                end
                              rescue RuleFailure => ex
                                self._pos = _p215
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            ""
                          end
                          begin
                            begin
                              _p219 = _pos
                              begin
                                ws()
                                if _string.startsWith("{", _pos)
                                  self._pos += 1
                                  "{"
                                else
                                  raise @error
                                end
                                bs = (
                                  begin
                                    as217 = ArrayList.new
                                    begin
                                      while true do
                                        _li = Object(
                                          self.cbraces()
                                        )
                                        as217.add(_li)
                                      end
                                    rescue RuleFailure; end
                                    as217
                                  end
                                )
                                if _string.startsWith("}", _pos)
                                  self._pos += 1
                                  "}"
                                else
                                  raise @error
                                end
                                begin
                                  
                                          ["Method", "#{s}#{n}", "#{join(as)}", "#{returntypeopt ? ":#{returntypeopt}" : ""}", "#{join(bs)}", m]
                                      
                                end
                              rescue RuleFailure => ex
                                self._pos = _p219
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            raise SyntaxError.new("", @error.last, _pos, _string, _list)
                          end
                        rescue RuleFailure => ex
                          self._pos = _p220
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p221
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p222
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.method", _start, ex)
      else
        _t = _memoize("MMetaParser.method", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'method'
      raise ex
    end
  end
  

  
  def jimport
    
    begin
      _start = _pos; stm = nil; xs = nil
      _t = _sretrieve("MMetaParser.jimport")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p227 = _pos
            begin
              stm = (
                self.k("import")
              )
              begin
                begin
                  _p226 = _pos
                  begin
                    xs = (
                      begin
                        as224 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p223 = _pos
                                begin
                                  begin  # not
                                    self.oneOf(";\n")
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p223
                                  raise ex
                                end
                              end
                            )
                            as224.add(_li)
                          end
                        rescue RuleFailure; end
                        as224
                      end
                    )
                    begin  # optional
                      if _string.startsWith(";", _pos)
                        self._pos += 1
                        ";"
                      else
                        raise @error
                      end
                    rescue RuleFailure
                      nil
                    end
                    ["Import", "#{stm}#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p226
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p227
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.jimport", _start, ex)
      else
        _t = _memoize("MMetaParser.jimport", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'jimport'
      raise ex
    end
  end
  

  
  def jpackage
    
    begin
      _start = _pos; stm = nil; xs = nil
      _t = _sretrieve("MMetaParser.jpackage")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p232 = _pos
            begin
              stm = (
                self.k("package")
              )
              begin
                begin
                  _p231 = _pos
                  begin
                    xs = (
                      begin
                        as229 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p228 = _pos
                                begin
                                  begin  # not
                                    self.oneOf(";\n")
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p228
                                  raise ex
                                end
                              end
                            )
                            as229.add(_li)
                          end
                        rescue RuleFailure; end
                        as229
                      end
                    )
                    begin  # optional
                      if _string.startsWith(";", _pos)
                        self._pos += 1
                        ";"
                      else
                        raise @error
                      end
                    rescue RuleFailure
                      nil
                    end
                    ["Package", "#{stm}#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p231
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p232
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.jpackage", _start, ex)
      else
        _t = _memoize("MMetaParser.jpackage", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'jpackage'
      raise ex
    end
  end
  

  
  def classdef
    
    begin
      _start = _pos; q = nil; xs = nil; bs = nil
      _t = _sretrieve("MMetaParser.classdef")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p240 = _pos
            begin
              q = (
                self.qualifiers()
              )
              ws()
              self.k("class")
              begin
                begin
                  _p239 = _pos
                  begin
                    xs = (
                      begin
                        as235 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p234 = _pos
                                begin
                                  begin  # not
                                    if _string.startsWith("{", _pos)
                                      self._pos += 1
                                      "{"
                                    else
                                      raise @error
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p234
                                  raise ex
                                end
                              end
                            )
                            as235.add(_li)
                          end
                        rescue RuleFailure; end
                        as235
                      end
                    )
                    if _string.startsWith("{", _pos)
                      self._pos += 1
                      "{"
                    else
                      raise @error
                    end
                    bs = (
                      begin
                        as237 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.cbraces()
                            )
                            as237.add(_li)
                          end
                        rescue RuleFailure; end
                        as237
                      end
                    )
                    if _string.startsWith("}", _pos)
                      self._pos += 1
                      "}"
                    else
                      raise @error
                    end
                    ["Class", q, " class #{join(xs)}", "#{join(bs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p239
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p240
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.classdef", _start, ex)
      else
        _t = _memoize("MMetaParser.classdef", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'classdef'
      raise ex
    end
  end
  

  
  def ruleMethod
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.ruleMethod")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p241 = _pos
              begin
                ws()
                self.method()
              rescue RuleFailure => ex
                self._pos = _p241
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p242 = _pos
              begin
                ws()
                self.rule()
              rescue RuleFailure => ex
                self._pos = _p242
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ruleMethod", _start, ex)
      else
        _t = _memoize("MMetaParser.ruleMethod", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ruleMethod'
      raise ex
    end
  end
  

  
  def parser
    
    begin
      _start = _pos; m = nil; n = nil; sn = nil; rs = nil; p = nil
      _t = _sretrieve("MMetaParser.parser")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p251 = _pos
            begin
              ws()
              m = (
                begin
                  self.k("public")
                rescue RuleFailure
                  self.empty()
                end
              )
              ws()
              self.k("parser")
              begin
                begin
                  _p250 = _pos
                  begin
                    ws()
                    n = (
                      self.name()
                    )
                    ws()
                    sn = (
                      begin
                        begin
                          _p245 = _pos
                          begin
                            begin
                              self.k("extends")
                            rescue RuleFailure
                              begin
                                _p244 = _pos
                                begin
                                  ws()
                                  if _string.startsWith("<", _pos)
                                    self._pos += 1
                                    "<"
                                  else
                                    raise @error
                                  end
                                rescue RuleFailure => ex
                                  self._pos = _p244
                                  raise ex
                                end
                              end
                            end
                            ws()
                            self.name()
                          rescue RuleFailure => ex
                            self._pos = _p245
                            raise ex
                          end
                        end
                      rescue RuleFailure
                        begin
                          _p246 = _pos
                          begin
                            self.empty()
                            "BaseParser"
                          rescue RuleFailure => ex
                            self._pos = _p246
                            raise ex
                          end
                        end
                      end
                    )
                    ws()
                    if _string.startsWith("{", _pos)
                      self._pos += 1
                      "{"
                    else
                      raise @error
                    end
                    rs = (
                      begin
                        as248 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.ruleMethod()
                            )
                            as248.add(_li)
                          end
                        rescue RuleFailure; end
                        as248
                      end
                    )
                    ws()
                    if _string.startsWith("}", _pos)
                      self._pos += 1
                      "}"
                    else
                      raise @error
                    end
                    p = (
                      concat(["Parser", m, n, sn], rs)
                    )
                    begin
                      begin
                        
                                           if (Boolean.getBoolean("mmeta.optimize.debug"))
                                             System.out.println("Before:\n" + BaseParser.print_r(p));
                                           end
                                           MMetaOptimizer.new().parse(p, "optimizeGrammar");
                                        
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p250
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p251
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.parser", _start, ex)
      else
        _t = _memoize("MMetaParser.parser", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'parser'
      raise ex
    end
  end
  

  
  def line
    
    begin
      _start = _pos; p = nil; l = nil
      _t = _sretrieve("MMetaParser.line")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p252 = _pos
            begin
              p = (
                ws()
              )
              l = (
                begin
                  self.parser()
                rescue RuleFailure
                  begin
                    self.jpackage()
                  rescue RuleFailure
                    begin
                      self.jimport()
                    rescue RuleFailure
                      self.classdef()
                    end
                  end
                end
              )
              ["Line", "#{join(p)}", l]
            rescue RuleFailure => ex
              self._pos = _p252
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.line", _start, ex)
      else
        _t = _memoize("MMetaParser.line", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'line'
      raise ex
    end
  end
  

  
  def file
    
    begin
      _start = _pos; ls = nil
      _t = _sretrieve("MMetaParser.file")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p254 = _pos
              begin
                ls = (
                  begin
                    as253 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.line()
                        )
                        as253.add(_li)
                      end
                    rescue RuleFailure; end
                    as253
                  end
                )
                ws()
                self.end()
                concat(["File"], ls)
              rescue RuleFailure => ex
                self._pos = _p254
                raise ex
              end
            end
          rescue RuleFailure
            raise SyntaxError.new("", @error.last, _pos, _string, _list)
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.file", _start, ex)
      else
        _t = _memoize("MMetaParser.file", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'file'
      raise ex
    end
  end
  

  
  def start
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.start")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          self.file()
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.start", _start, ex)
      else
        _t = _memoize("MMetaParser.start", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'start'
      raise ex
    end
  end
  


  def _jump(r:String)
    return sp() if (r == "sp")
    return ws() if (r == "ws")
    return nameFirst() if (r == "nameFirst")
    return nameRest() if (r == "nameRest")
    return name() if (r == "name")
    return rulename() if (r == "rulename")
    return varname() if (r == "varname")
    return hex() if (r == "hex")
    return echar() if (r == "echar")
    return tsString() if (r == "tsString")
    return dollar() if (r == "dollar")
    return dollarstring() if (r == "dollarstring")
    return string() if (r == "string")
    return number() if (r == "number")
    return symbol() if (r == "symbol")
    return error() if (r == "error")
    return any() if (r == "any")
    return wsdot() if (r == "wsdot")
    return args() if (r == "args")
    return application() if (r == "application")
    return fname() if (r == "fname")
    return parens() if (r == "parens")
    return dotted_name() if (r == "dotted_name")
    return rewrite_expr() if (r == "rewrite_expr")
    return simplehost() if (r == "simplehost")
    return simplehost1() if (r == "simplehost1")
    return cbraces() if (r == "cbraces")
    return semAction() if (r == "semAction")
    return semPred() if (r == "semPred")
    return synPred() if (r == "synPred")
    return synPredTail() if (r == "synPredTail")
    return token() if (r == "token")
    return tokens() if (r == "tokens")
    return expr() if (r == "expr")
    return expr4() if (r == "expr4")
    return expr3() if (r == "expr3")
    return expr2() if (r == "expr2")
    return expr1() if (r == "expr1")
    return annotation() if (r == "annotation")
    return ruleArgs() if (r == "ruleArgs")
    return rule() if (r == "rule")
    return qualifiers() if (r == "qualifiers")
    return method() if (r == "method")
    return jimport() if (r == "jimport")
    return jpackage() if (r == "jpackage")
    return classdef() if (r == "classdef")
    return ruleMethod() if (r == "ruleMethod")
    return parser() if (r == "parser")
    return line() if (r == "line")
    return file() if (r == "file")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "sp")
    return true if (r == "ws")
    return true if (r == "nameFirst")
    return true if (r == "nameRest")
    return true if (r == "name")
    return true if (r == "rulename")
    return true if (r == "varname")
    return true if (r == "hex")
    return true if (r == "echar")
    return true if (r == "tsString")
    return true if (r == "dollar")
    return true if (r == "dollarstring")
    return true if (r == "string")
    return true if (r == "number")
    return true if (r == "symbol")
    return true if (r == "error")
    return true if (r == "any")
    return true if (r == "wsdot")
    return true if (r == "args")
    return true if (r == "application")
    return true if (r == "fname")
    return true if (r == "parens")
    return true if (r == "dotted_name")
    return true if (r == "rewrite_expr")
    return true if (r == "simplehost")
    return true if (r == "simplehost1")
    return true if (r == "cbraces")
    return true if (r == "semAction")
    return true if (r == "semPred")
    return true if (r == "synPred")
    return true if (r == "synPredTail")
    return true if (r == "token")
    return true if (r == "tokens")
    return true if (r == "expr")
    return true if (r == "expr4")
    return true if (r == "expr3")
    return true if (r == "expr2")
    return true if (r == "expr1")
    return true if (r == "annotation")
    return true if (r == "ruleArgs")
    return true if (r == "rule")
    return true if (r == "qualifiers")
    return true if (r == "method")
    return true if (r == "jimport")
    return true if (r == "jpackage")
    return true if (r == "classdef")
    return true if (r == "ruleMethod")
    return true if (r == "parser")
    return true if (r == "line")
    return true if (r == "file")
    return true if (r == "start")
    super(r)
  end
end



class MMetaPass < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  def init()
    
        @changed = false
      
  end
  

  def changed()
    
        @changed
      
  end
  

  def changed_set(value:boolean)
    
        @changed = value
      
  end
  

  
  def setChanged
    
    begin
      _start = _pos
      _t = _sretrieve("MMetaPass.setChanged")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            @changed = true; nil;
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.setChanged", _start, ex)
      else
        _t = _memoize("MMetaPass.setChanged", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'setChanged'
      raise ex
    end
  end
  

  
  def destruct
    
    begin
      _start = _pos; r = nil; x = nil
      _t = _sretrieve("MMetaPass.destruct")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p256 = _pos
            begin
              r = (
                self._any()
              )
              raise @error unless ( hasRule(r) )
              begin
                begin
                  _p255 = _pos
                  begin
                    x = (
                      self.apply(r)
                    )
                    self.end()
                    x
                  rescue RuleFailure => ex
                    self._pos = _p255
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p256
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.destruct", _start, ex)
      else
        _t = _memoize("MMetaPass.destruct", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'destruct'
      raise ex
    end
  end
  

  
  def trans
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.trans")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p257 = _pos
              begin
                begin
                  _t = _listBegin()
                  begin
                    x = (
                      self.destruct()
                    )
                  ensure
                    _listEnd()
                  end
                end
                x
              rescue RuleFailure => ex
                self._pos = _p257
                raise ex
              end
            end
          rescue RuleFailure
            self._any()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.trans", _start, ex)
      else
        _t = _memoize("MMetaPass.trans", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'trans'
      raise ex
    end
  end
  

  
  def Or
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaPass.Or")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p259 = _pos
            begin
              xs = (
                begin
                  as258 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as258.add(_li)
                    end
                  rescue RuleFailure; end
                  as258
                end
              )
              concat(["Or"], xs)
            rescue RuleFailure => ex
              self._pos = _p259
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Or", _start, ex)
      else
        _t = _memoize("MMetaPass.Or", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Or'
      raise ex
    end
  end
  

  
  def And
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaPass.And")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p261 = _pos
            begin
              xs = (
                begin
                  as260 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as260.add(_li)
                    end
                  rescue RuleFailure; end
                  as260
                end
              )
              concat(["And"], xs)
            rescue RuleFailure => ex
              self._pos = _p261
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.And", _start, ex)
      else
        _t = _memoize("MMetaPass.And", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'And'
      raise ex
    end
  end
  

  
  def Not
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Not")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p262 = _pos
            begin
              x = (
                self.trans()
              )
              ["Not", x]
            rescue RuleFailure => ex
              self._pos = _p262
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Not", _start, ex)
      else
        _t = _memoize("MMetaPass.Not", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Not'
      raise ex
    end
  end
  

  
  def Many
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Many")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p263 = _pos
            begin
              x = (
                self.trans()
              )
              ["Many", x]
            rescue RuleFailure => ex
              self._pos = _p263
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Many", _start, ex)
      else
        _t = _memoize("MMetaPass.Many", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Many'
      raise ex
    end
  end
  

  
  def Many1
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Many1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p264 = _pos
            begin
              x = (
                self.trans()
              )
              ["Many1", x]
            rescue RuleFailure => ex
              self._pos = _p264
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Many1", _start, ex)
      else
        _t = _memoize("MMetaPass.Many1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Many1'
      raise ex
    end
  end
  

  
  def Peek
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Peek")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p265 = _pos
            begin
              x = (
                self.trans()
              )
              ["Peek", x]
            rescue RuleFailure => ex
              self._pos = _p265
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Peek", _start, ex)
      else
        _t = _memoize("MMetaPass.Peek", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Peek'
      raise ex
    end
  end
  

  
  def List
    
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.List")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p266 = _pos
            begin
              x = (
                self.trans()
              )
              ["List", x]
            rescue RuleFailure => ex
              self._pos = _p266
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.List", _start, ex)
      else
        _t = _memoize("MMetaPass.List", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'List'
      raise ex
    end
  end
  

  
  def Set
    
    begin
      _start = _pos; n = nil; x = nil
      _t = _sretrieve("MMetaPass.Set")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p267 = _pos
            begin
              n = (
                self._any()
              )
              x = (
                self.trans()
              )
              ["Set", n, x]
            rescue RuleFailure => ex
              self._pos = _p267
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Set", _start, ex)
      else
        _t = _memoize("MMetaPass.Set", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Set'
      raise ex
    end
  end
  

  
  def Rule
    
    begin
      _start = _pos; n = nil; args = nil; x = nil; anno = nil
      _t = _sretrieve("MMetaPass.Rule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p268 = _pos
            begin
              n = (
                self._any()
              )
              args = (
                self._any()
              )
              x = (
                self.trans()
              )
              anno = (
                self._any()
              )
              ["Rule", n, args, x, anno]
            rescue RuleFailure => ex
              self._pos = _p268
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Rule", _start, ex)
      else
        _t = _memoize("MMetaPass.Rule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Rule'
      raise ex
    end
  end
  

  
  def SynPred
    
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaPass.SynPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p270 = _pos
            begin
              xs = (
                begin
                  as269 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as269.add(_li)
                    end
                  rescue RuleFailure; end
                  as269
                end
              )
              concat(["SynPred"], xs)
            rescue RuleFailure => ex
              self._pos = _p270
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.SynPred", _start, ex)
      else
        _t = _memoize("MMetaPass.SynPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'SynPred'
      raise ex
    end
  end
  

  
  def Error
    
    begin
      _start = _pos; m = nil; x = nil
      _t = _sretrieve("MMetaPass.Error")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p271 = _pos
            begin
              m = (
                self._any()
              )
              x = (
                self.trans()
              )
              ["Error", m, x]
            rescue RuleFailure => ex
              self._pos = _p271
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Error", _start, ex)
      else
        _t = _memoize("MMetaPass.Error", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Error'
      raise ex
    end
  end
  

  
  def start
    
    begin
      _start = _pos; r = nil
      _t = _sretrieve("MMetaPass.start")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p272 = _pos
              begin
                r = (
                  self.destruct()
                )
                self.end()
                r
              rescue RuleFailure => ex
                self._pos = _p272
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p273 = _pos
                begin
                  r = (
                    self._any()
                  )
                  self.end()
                  r
                rescue RuleFailure => ex
                  self._pos = _p273
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                _p275 = _pos
                begin
                  r = (
                    begin
                      as274 = ArrayList.new
                      begin
                        while true do
                          _li = Object(
                            self._any()
                          )
                          as274.add(_li)
                        end
                      rescue RuleFailure; end
                      as274
                    end
                  )
                  self.end()
                  r
                rescue RuleFailure => ex
                  self._pos = _p275
                  raise ex
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.start", _start, ex)
      else
        _t = _memoize("MMetaPass.start", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'start'
      raise ex
    end
  end
  


  def _jump(r:String)
    return setChanged() if (r == "setChanged")
    return destruct() if (r == "destruct")
    return trans() if (r == "trans")
    return Or() if (r == "Or")
    return And() if (r == "And")
    return Not() if (r == "Not")
    return Many() if (r == "Many")
    return Many1() if (r == "Many1")
    return Peek() if (r == "Peek")
    return List() if (r == "List")
    return Set() if (r == "Set")
    return Rule() if (r == "Rule")
    return SynPred() if (r == "SynPred")
    return Error() if (r == "Error")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "setChanged")
    return true if (r == "destruct")
    return true if (r == "trans")
    return true if (r == "Or")
    return true if (r == "And")
    return true if (r == "Not")
    return true if (r == "Many")
    return true if (r == "Many1")
    return true if (r == "Peek")
    return true if (r == "List")
    return true if (r == "Set")
    return true if (r == "Rule")
    return true if (r == "SynPred")
    return true if (r == "Error")
    return true if (r == "start")
    super(r)
  end
end



class MMetaAndOrOpt < MMetaPass
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  
  def And
    
    begin
      _start = _pos; x = nil; xs = nil
      _t = _sretrieve("MMetaAndOrOpt.And")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p276 = _pos
              begin
                x = (
                  self.trans()
                )
                self.end()
                self.setChanged()
                x
              rescue RuleFailure => ex
                self._pos = _p276
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p277 = _pos
              begin
                xs = (
                  self.transInside("And")
                )
                self.end()
                concat(["And"], xs)
              rescue RuleFailure => ex
                self._pos = _p277
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaAndOrOpt.And", _start, ex)
      else
        _t = _memoize("MMetaAndOrOpt.And", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'And'
      raise ex
    end
  end
  

  
  def Or
    
    begin
      _start = _pos; x = nil; xs = nil
      _t = _sretrieve("MMetaAndOrOpt.Or")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p278 = _pos
              begin
                x = (
                  self.trans()
                )
                self.end()
                self.setChanged()
                x
              rescue RuleFailure => ex
                self._pos = _p278
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p279 = _pos
              begin
                xs = (
                  self.transInside("Or")
                )
                self.end()
                concat(["Or"], xs)
              rescue RuleFailure => ex
                self._pos = _p279
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaAndOrOpt.Or", _start, ex)
      else
        _t = _memoize("MMetaAndOrOpt.Or", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Or'
      raise ex
    end
  end
  

  
  def transInside(s:String)
    
    begin
      _start = _pos; xs = nil; ys = nil; x = nil
      begin
        begin
          _p281 = _pos
          begin
            begin
              _t = _listBegin()
              begin
                begin
                  _p280 = _pos
                  begin
                    self.sym(s)
                    xs = (
                      self.transInside(s)
                    )
                  rescue RuleFailure => ex
                    self._pos = _p280
                    raise ex
                  end
                end
              ensure
                _listEnd()
              end
            end
            ys = (
              self.transInside(s)
            )
            self.setChanged()
            concat(xs, ys)
          rescue RuleFailure => ex
            self._pos = _p281
            raise ex
          end
        end
      rescue RuleFailure
        begin
          begin
            _p282 = _pos
            begin
              x = (
                self.trans()
              )
              xs = (
                self.transInside(s)
              )
              concat([x], xs)
            rescue RuleFailure => ex
              self._pos = _p282
              raise ex
            end
          end
        rescue RuleFailure
          ArrayList.new
        end
      end
    rescue RuleFailure => ex
      ex.last = 'transInside'
      raise ex
    end
  end
  


  def _jump(r:String)
    return And() if (r == "And")
    return Or() if (r == "Or")
    super(r)
  end

  def _has(r:String)
    return true if (r == "And")
    return true if (r == "Or")
    super(r)
  end
end



class MMetaOptimizer < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  
  def optimizeGrammar
    
    begin
      _start = _pos; p = nil; n = nil; sn = nil; rs = nil; x = nil
      _t = _sretrieve("MMetaOptimizer.optimizeGrammar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p284 = _pos
              begin
                _sym("Parser")
                p = (
                  self._any()
                )
                n = (
                  self._any()
                )
                sn = (
                  self._any()
                )
                rs = (
                  begin
                    as283 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.optimizeRule()
                        )
                        as283.add(_li)
                      end
                    rescue RuleFailure; end
                    as283
                  end
                )
                self.end()
                x = (
                  concat(["Parser", p, n, sn], rs)
                )
                begin
                  
                                         if (Boolean.getBoolean("mmeta.optimize.debug"))
                                           System.out.println("Opt:\n" + BaseParser.print_r(x))
                                         end
                                         x
                                       
                end
              rescue RuleFailure => ex
                self._pos = _p284
                raise ex
              end
            end
          rescue RuleFailure
            raise SyntaxError.new("", @error.last, _pos, _string, _list)
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaOptimizer.optimizeGrammar", _start, ex)
      else
        _t = _memoize("MMetaOptimizer.optimizeGrammar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'optimizeGrammar'
      raise ex
    end
  end
  

  
  def optimizeRule
    
    begin
      _start = _pos; r = nil
      _t = _sretrieve("MMetaOptimizer.optimizeRule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p285 = _pos
            begin
              r = (
                self._any()
              )
              begin
                
                        MMetaAndOrOpt opt = MMetaAndOrOpt.new()
                        begin
                            opt.changed = false
                            r = opt.parse(r)
                        end while (opt.changed)
                        r
                    
              end
            rescue RuleFailure => ex
              self._pos = _p285
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaOptimizer.optimizeRule", _start, ex)
      else
        _t = _memoize("MMetaOptimizer.optimizeRule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'optimizeRule'
      raise ex
    end
  end
  


  def _jump(r:String)
    return optimizeGrammar() if (r == "optimizeGrammar")
    return optimizeRule() if (r == "optimizeRule")
    super(r)
  end

  def _has(r:String)
    return true if (r == "optimizeGrammar")
    return true if (r == "optimizeRule")
    super(r)
  end
end
