// copyright 2009 ActiveVideo; license: MIT; see license.txt
package jmeta;
import java.util.*;
import org.stringtemplate.v4.*

public parser MMetaCompiler {
    def self.main(args:String[]) {
      returns void
      if args.length < 1
          puts "JMetaParser <input> [output]"
          System.exit(2)
      end
      # if args.length > 1 && args[1].equals("--embed")
      #     embed = true
      # end
      options = {recursion: Boolean.valueOf(false), auto_memo: Boolean.valueOf(false)}
      i = 0
      while i < args.length && args[i].startsWith('--')
        arg = args[i].substring(2)
        if options.containsKey(arg)
          options.put(arg, Boolean.valueOf(true))
        else
          puts "Unrecognized option --#{arg}."
          puts "Supported options: #{options.keySet}"
          System.exit(1)
        end
        i += 1
      end
      if args.length > i
        output_file = args[i + 1]
      else
        output_file = args[i] + ".mirah"
      end
      input = Utils.readFile(args[i])

      compiler = MMetaCompiler.new
      compiler.left_recursion = Boolean(options.get(:recursion)).booleanValue
      compiler.auto_memo = Boolean(options.get(:auto_memo)).booleanValue
      # compiler.embedded = embed
      parser = JMetaParser.new
      BaseParser.tracing = false
      ast = parser.parse(input)
      BaseParser.tracing = false
      # puts BaseParser.print_r(ast)

      output = String(compiler.parse(ast))
      Utils.writeFile(output_file, output)
      System.exit(0)
    }

    def initialize {
      @jpackage = String(nil)
      @embedded = false
      @locals = ArrayList.new
      @methods = ArrayList.new
      @rules = ArrayList.new
      @ranges = HashMap.new
      @sname = "ERROR-sname-ERROR"
      @name = "ERROR-name-ERROR"
      @_ = "  "
      @__genc = -1
      @left_recursion = Boolean.getBoolean("mmeta.left_recursion")
      @auto_memo = Boolean.getBoolean("mmeta.auto_memo")
      @templates = STGroupFile.new(MMetaCompiler.class.getResource("mmeta_compiler.stg"), "utf-8", '<'.charAt(0), '>'.charAt(0))
    }

    def left_recursion_set(value:boolean) {
      @left_recursion = value
    }

    def auto_memo_set(value:boolean) {
      @auto_memo = value
    }

    def render(name:String, args:Map) {
      st = @templates.getInstanceOf(name)
      args.keySet().each do |k|
        st.add(String(k), args.get(k))
      end
      st.render
    }

    def reset {
        @locals = ArrayList.new
        @methods = ArrayList.new
        @rules = ArrayList.new
    }

    def addLocal(n:Object) {
        s = String(n).intern
        @locals.add(s) unless @locals.contains(s)
    }
    def localsAsArgs {
      localsAsCall
    }
    def localsAsCall {
        join(@locals, ",")
    }
    def localsAsInit {
      return '' if @locals.size == 0
      res = join(@locals, " = ") + " = Object(nil)\n"
      @locals.clear
      res
    }

    def embedded_set(embedded:boolean) {@embeded = embedded}

    def genvar { "" + (@__genc = @__genc + 1); }

    destruct: ! t=_ r=apply(t) end    { r } ;
    trans: [ r=destruct ]             { r } ;

    HList ls=trans* {
      if List(ls).size == 0
        "ArrayList.new"
      else
        "[#{join(ls, ", ")}]"
      end
    };
    HConcat l=trans r=trans { "concat(#{l}, #{r})" };
    HStr c=_ { "\"#{c}\"" };
    HLit c=_ { c } ;

    Node n=_ c=trans {"build_node('#{n}', #{c}, _real_start > 1 ? _real_start : _start, _pos)"};

    Error msg=_ {
        DoError.new(msg);
    };
    Set n=_ x=trans {
        addLocal(n);
        render('save_to_var', name: n, expr: x)
    };
    Str s=_ { compile_literal_string(s) };
    Sym s=_ { "_t=_sym(\"#{s}\");" };


    App :super rule=_ args=trans+ {
        arg_str = if List(args).size == 1
          join(args, ", ")
        else
          "ArrayList.new([#{join(args, ", ")}]).toArray"
        end
        "_push(#{arg_str}); _t=super();"
    };
    App :super rule=_ { "_t=super();" };
    App rule=_ args=trans+ {
        arg_str = if List(args).size == 1
          join(args, ", ")
        else
          "ArrayList.new([#{join(args, ", ")}]).toArray"
        end
        "_push(#{arg_str}); _t=self.#{rule}();"
    };
    App rule=_ { "_t=self.#{rule}();" };

    # Don't include whitespace at the beginning of the rule in it's position
    Dot {"if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;"};

    SAct expr=trans { "_t=#{expr};" };
    Act expr=_ {
        render('action', expr: expr)
    };
    Pred expr=_ {
        render('predicate', expr: expr)
    };
    SynPred! pred=trans t=trans e=trans {
      render('syn_pred', pred: pred, t:t, e:e)
    };

    Token name=_ {
      "_t = _lex(Tokens.t#{name})\n"
    };
    TokenRange first=_ last=_ {
      range = lookup_range(first, last)
      render('token_range', first: first, last: last, range: range)
    };
    TLit name=_ {
      token = Integer.valueOf(lookup_token(name))
      render('token_literal', name: name, token: token)
    };

    Or xs=trans* {
      render('or', exprs: xs)
    };


    And ts=trans+ {
        var = genvar
        err = null
        xs = List(ts)
        nodes = ArrayList.new(xs.size)
        errors = ArrayList.new(xs.size)
        xs.each do |x|
          if x.kind_of?(DoError)
            err = DoError(x).message
            next
          end
          nodes.add(x)
          errors.add(err)
        end
        render('and', var: var, exprs: nodes, errors: errors)
    };
    And { "" };

    def makeMany(x:Object, many1:boolean) {
        var = genvar
        if many1
          render('build_list_no_empty', x: x, var: var)
        else
          render('build_list', x: x, var: var)
        end
    }
    Many x=trans { makeMany(x, false) } ;
    Many1 x=trans { makeMany(x, true)  } ;

    Opt x=trans { render('opt', x: x) };

    Not x=trans { render('not', x: x)};

    Peek x=trans {
      var = genvar
      render('peek', x: x, var: var)
    };

    List x=trans {
        render('list', x: x)
    };

    MemoRule n=_ b=trans {
      rule_body(n, b, true)
    };

    Rule n=_ b=trans {
      rule_body(n, b, false)
    };

    Scope names=_ body=trans {
      simple_names = ArrayList.new
      l = Object[].cast(names)
      l.each do |_name|
        name = String(_name)
        simple_names.add(name.replace('@', ''))
      end
      render('scope', names: names, simple_names: simple_names, body: body)
    };

    Parser p=_ n=_ s=_ { @name = String(n); @sname = String(s); nil } xs=trans* {
      init = build_init
      b = render('parser', name: @name, superclass: @sname, init: init, xs:xs, methods:@methods, rules:@rules)
      reset
      b
    };

    Method name=_ args=_ body=_ { render('method', name:name, args:args, body:body) };
    Method  c=_ { "  #{c}\n" } ;
    Field   c=_ { "  #{c}\n" } ;
    Package c=_ { @jpackage = String(c); ""; } ;
    Import  c=_ { c } ;
    Class   q=_ d=_ c=_ { "#{d}\n#{c}\nend" } ;
    Line  ws=_ x=trans { ws.toString + x.toString } ;

    File  xs=trans* {
        "# generated by mmeta on #{Date.new}\n" +
        "# do not modify, instead edit original .mmeta file\n" +
        "import java.util.ArrayList\n" +
        "import java.util.Date\n" +
        "import java.util.List\n" +
        "import java.util.EnumSet\n" +
        (@embedded ? "" : "import jmeta.*;\n") + join(xs)
    } ;

    start: ! r=destruct end           { r } ;

    def unescape(s:String) {
      sb = StringBuilder.new
      i = 0
      while i < s.length
        if s.charAt(i) == 92 # ?\\
          i += 1
          c = s.substring(i, i + 1)
          if c.equals("n")
            sb.append("\n")
          elsif c == "s"
            sb.append("\s")
          elsif c == "r"
            sb.append("\r")
          elsif c == "t"
            sb.append("\t")
          elsif c == "v"
            sb.append("\v")
          elsif c == "f"
            sb.append("\f")
          elsif c == "b"
            sb.append("\b")
          elsif c == "a"
            sb.append("\a")
          elsif c == "e"
            sb.append("\e")
          else
            sb.append(c)
          end
        else
          sb.append(s.charAt(i))
        end
        i += 1
      end
      str = sb.toString
      ints = int[str.length]
      ints.length.times do |i|
        ints[i] = str.charAt(i)
      end
      ints
    }

    def compile_literal_string(_s:Object) {
      s = unescape(String(_s))
      if s.length == 0
        "_t = ''\n"
      else
        var = "_p#{genvar}"
        render('literal_string', string:_s, chars: s, var: var)
      end
    }

    def lookup_token(name:Object) {
      @tokens ||= ArrayList.new
      index = @tokens.indexOf(name)
      if index == -1
        index = @tokens.size
        @tokens.add(name)
      end
      return index
    }

    def lookup_range(first:Object, last:Object) {
      key = "#{first},#{last}"
      val = String(@ranges.get(key))
      if val.nil?
        val = "@_trange#{@ranges.size}"
        @ranges.put(key, val)
      end
      val
    }

    def build_init {
      code = StringBuilder.new("\n@chars = _chars\nsuper()\n")
      @ranges.keySet.each do |key|
        tokens = String(key).split(",")
        first = tokens[0]
        last = tokens[1]
        name = @ranges.get(key)
        code.append("#{name} = EnumSet.range(Tokens.t#{first}, Tokens.t#{last})\n")
      end
      code.toString
    }

    def rule_body(n:Object, b:Object, force_memo:boolean) {
      @rules.add(n)
      locals = localsAsInit
      render('rule_body', n:n, name:@name, memo: Boolean.valueOf(force_memo || @auto_memo),
             b:b, recursion:Boolean.valueOf(@left_recursion), locals:locals)

    }
}
