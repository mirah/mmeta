# generated by mmeta on Tue Oct 26 14:20:25 PDT 2010
# do not modify, instead edit original .mmeta file
import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import jmeta.*;


import java.util.*;


class MMetaCompiler < BaseParser
  def _init;
@chars = _chars
super()
;end
  def self.main(args:String[]);
      returns void
      if args.length < 1
          puts "JMetaParser <input> [output]"
          System.exit(2)
      end
      # if args.length > 1 && args[1].equals("--embed")
      #     embed = true
      # end
      if args.length > 1
        output_file = args[1]
      else
        output_file = args[0] + ".mirah"
      end
      input = Utils.readFile(args[0])
      compiler = MMetaCompiler.new
      # compiler.embedded = embed
      parser = JMetaParser.new
      BaseParser.tracing = false
      ast = parser.parse(input)
      BaseParser.tracing = false
      # puts BaseParser.print_r(ast)

      output = String(compiler.parse(ast))
      Utils.writeFile(output_file, output)
      System.exit(0)
    ;end
  def initialize();
      @jpackage = String(nil)
      @embedded = false
      @locals = ArrayList.new
      @methods = ArrayList.new
      @rules = ArrayList.new
      @ranges = HashMap.new
      @sname = "ERROR-sname-ERROR"
      @name = "ERROR-name-ERROR"
      @_ = "  "
      @__genc = -1
      @left_recursion = Boolean.getBoolean("mmeta.left_recursion")
      @auto_memo = Boolean.getBoolean("mmeta.auto_memo")
    ;end
  def reset();
        @locals = ArrayList.new
        @methods = ArrayList.new
        @rules = ArrayList.new
    ;end
  def addLocal(n:Object);
        s = String(n).intern
        @locals.add(s) unless @locals.contains(s)
    ;end
  def localsAsArgs();
      localsAsCall
    ;end
  def localsAsCall();
        join(@locals, ",")
    ;end
  def localsAsInit();
      return '' if @locals.size == 0
      res = join(@locals, " = ") + " = Object(nil)\n"
      @locals.clear
      res
    ;end
  def embedded_set(embedded:boolean);@embeded = embedded;end
  def indent(); @_ = @_ + "  " ;end
  def outdent(); @_ = @_.substring(2) ;end
  def genvar(); "" + (@__genc = @__genc + 1); ;end

        def destruct:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('destruct')
          
          t = r = Object(nil)

          begin; _p0=_pos; _t=nil; begin  # and
    _t=self._any();
    t=_t;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _push(t); _t=self.apply();
    r=_t;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=self.end();
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=r;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
  end while false; self._pos=_p0 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="destruct" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def trans:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('trans')
          
          r = Object(nil)

          begin; _p1=_pos; _t=nil; begin  # and
    _t=_listBegin(); if (_t!=BaseParser.__ERROR__)
      _t=self.destruct();
      r=_t;
    _listEnd(); end;
    break if _t == BaseParser.__ERROR__
    _t=r;
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p1 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="trans" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def HList:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('HList')
          
          ls = Object(nil)

          begin; _p3=_pos; _t=nil; begin  # and
    as2 = ArrayList.new
    while true  # many
    _t=self.trans();
    if (_t==BaseParser.__ERROR__); break; else as2.add(_t);nil;end
    end; _t=as2

    ls=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
      if List(ls).size == 0
        "ArrayList.new"
      else
        "[#{join(ls, ", ")}]"
      end
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p3 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="HList" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def HConcat:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('HConcat')
          
          l = r = Object(nil)

          begin; _p4=_pos; _t=nil; begin  # and
    _t=self.trans();
    l=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    r=_t;
    break if _t == BaseParser.__ERROR__
    _t="concat(#{l}, #{r})";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p4 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="HConcat" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def HStr:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('HStr')
          
          c = Object(nil)

          begin; _p5=_pos; _t=nil; begin  # and
    _t=self._any();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t="\"#{c}\"";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p5 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="HStr" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def HLit:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('HLit')
          
          c = Object(nil)

          begin; _p6=_pos; _t=nil; begin  # and
    _t=self._any();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t=c;
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p6 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="HLit" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Node:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Node')
          
          n = c = Object(nil)

          begin; _p7=_pos; _t=nil; begin  # and
    _t=self._any();
    n=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t="build_node('#{n}', #{c}, _real_start > 1 ? _real_start : _start, _pos)";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p7 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Node" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Error:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Error')
          
          msg = Object(nil)

          begin; _p8=_pos; _t=nil; begin  # and
    _t=self._any();
    msg=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
        DoError.new(msg);
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p8 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Error" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Set:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Set')
          
          n = x = Object(nil)

          begin; _p9=_pos; _t=nil; begin  # and
    _t=self._any();
    n=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
        addLocal(n);
        "#{x}\n#{@_}#{n}=_t;"
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p9 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Set" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Str:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Str')
          
          s = Object(nil)

          begin; _p10=_pos; _t=nil; begin  # and
    _t=self._any();
    s=_t;
    break if _t == BaseParser.__ERROR__
    _t=( compile_literal_string(s) );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p10 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Str" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Sym:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Sym')
          
          s = Object(nil)

          begin; _p11=_pos; _t=nil; begin  # and
    _t=self._any();
    s=_t;
    break if _t == BaseParser.__ERROR__
    _t="_t=_sym(\"#{s}\");";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p11 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Sym" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def App:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('App')
          
          rule = args = Object(nil)

          _t=BaseParser.__ERROR__; begin  # or
    begin; _p13=_pos; _t=nil; begin  # and
      _t=_sym("super");
      break if _t == BaseParser.__ERROR__
      _t=self._any();
      rule=_t;
      break if _t == BaseParser.__ERROR__
      as12 = ArrayList.new
      _t=self.trans();
      if (_t!=BaseParser.__ERROR__)
        as12.add(_t)
        while true  # many
        _t=self.trans();
        if (_t==BaseParser.__ERROR__); break; else as12.add(_t);nil;end
        end; _t=as12

      end

      args=_t;
      break if _t == BaseParser.__ERROR__
      _t=(
        arg_str = if List(args).size == 1
          join(args, ", ")
        else
          "ArrayList.new([#{join(args, ", ")}]).toArray"
        end
        "_push(#{arg_str}); _t=super();"
    );
      break if _t == BaseParser.__ERROR__
    end while false; self._pos=_p13 if (_t==BaseParser.__ERROR__); end

    break unless _t == BaseParser.__ERROR__

    begin; _p14=_pos; _t=nil; begin  # and
      _t=_sym("super");
      break if _t == BaseParser.__ERROR__
      _t=self._any();
      rule=_t;
      break if _t == BaseParser.__ERROR__
      _t="_t=super();";
      break if _t == BaseParser.__ERROR__
    end while false; self._pos=_p14 if (_t==BaseParser.__ERROR__); end

    break unless _t == BaseParser.__ERROR__

    begin; _p16=_pos; _t=nil; begin  # and
      _t=self._any();
      rule=_t;
      break if _t == BaseParser.__ERROR__
      as15 = ArrayList.new
      _t=self.trans();
      if (_t!=BaseParser.__ERROR__)
        as15.add(_t)
        while true  # many
        _t=self.trans();
        if (_t==BaseParser.__ERROR__); break; else as15.add(_t);nil;end
        end; _t=as15

      end

      args=_t;
      break if _t == BaseParser.__ERROR__
      _t=(
        arg_str = if List(args).size == 1
          join(args, ", ")
        else
          "ArrayList.new([#{join(args, ", ")}]).toArray"
        end
        "_push(#{arg_str}); _t=self.#{rule}();"
    );
      break if _t == BaseParser.__ERROR__
    end while false; self._pos=_p16 if (_t==BaseParser.__ERROR__); end

    break unless _t == BaseParser.__ERROR__

    begin; _p17=_pos; _t=nil; begin  # and
      _t=self._any();
      rule=_t;
      break if _t == BaseParser.__ERROR__
      _t="_t=self.#{rule}();";
      break if _t == BaseParser.__ERROR__
    end while false; self._pos=_p17 if (_t==BaseParser.__ERROR__); end

    break unless _t == BaseParser.__ERROR__
  end while false

          _t=_exit(_t)
          BaseParser.__ERROR__.last="App" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Dot:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Dot')
          
          
          _t="if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;";
          _t=_exit(_t)
          BaseParser.__ERROR__.last="Dot" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def SAct:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('SAct')
          
          expr = Object(nil)

          begin; _p18=_pos; _t=nil; begin  # and
    _t=self.trans();
    expr=_t;
    break if _t == BaseParser.__ERROR__
    _t="_t=#{expr};";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p18 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="SAct" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Act:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Act')
          
          expr = Object(nil)

          begin; _p19=_pos; _t=nil; begin  # and
    _t=self._any();
    expr=_t;
    break if _t == BaseParser.__ERROR__
    _t="_t=(#{expr});";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p19 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Act" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Pred:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Pred')
          
          expr = Object(nil)

          begin; _p20=_pos; _t=nil; begin  # and
    _t=self._any();
    expr=_t;
    break if _t == BaseParser.__ERROR__
    _t="_t = (#{expr}) ? nil : BaseParser.__ERROR__;";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p20 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Pred" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def SynPred:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('SynPred')
          
          pred = t = e = Object(nil)

          begin; _p21=_pos; _t=nil; begin  # and
    _t=self.trans();
    pred=_t;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=self.indent();
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=self.trans();
    t=_t;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=self.trans();
    e=_t;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=(
      "#{pred}\n#{outdent}" \
      "unless _t == BaseParser.__ERROR__\n" \
      "#{@_}_t=nil\n" \
      "#{@_}#{t}\n" \
      "#{@_}nil\n" \
      "#{@_}else\n" \
      "#{@_}_t=nil\n" \
      "#{@_}#{e}\n" \
      "#{@_}nil\n" \
      "#{@_}end\n"
    );
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
  end while false; self._pos=_p21 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="SynPred" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Token:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Token')
          
          name = Object(nil)

          begin; _p22=_pos; _t=nil; begin  # and
    _t=self._any();
    name=_t;
    break if _t == BaseParser.__ERROR__
    _t="#{@_}_t = _lex(Tokens.t#{name})\n";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p22 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Token" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def TokenRange:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('TokenRange')
          
          first = last = Object(nil)

          begin; _p23=_pos; _t=nil; begin  # and
    _t=self._any();
    first=_t;
    break if _t == BaseParser.__ERROR__
    _t=self._any();
    last=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
      "#{@_}_tok = _lex()  # #{first}..#{last}\n" \
      "_t = #{lookup_range(first, last)}.contains(_tok.type) ? Object(_tok) : BaseParser.__ERROR__\n" \
      "self._pos=_tok.pos if _t == BaseParser.__ERROR__"
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p23 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="TokenRange" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def TLit:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('TLit')
          
          name = Object(nil)

          begin; _p24=_pos; _t=nil; begin  # and
    _t=self._any();
    name=_t;
    break if _t == BaseParser.__ERROR__
    _t=" # #{name}\n#{@_}    build_token(#{lookup_token(name)}, _start, _real_start)";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p24 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="TLit" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Or:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Or')
          
          x = xs = Object(nil)

          begin; _p27=_pos; _t=nil; begin  # and
    _t=self.indent();
    break if _t == BaseParser.__ERROR__
    as26 = ArrayList.new
    while true  # many
    begin; _p25=_pos; _t=nil; begin  # and
        _t=self.trans();
        x=_t;
        break if _t == BaseParser.__ERROR__
        _t="#{@_}#{x}\n#{@_}break unless _t == BaseParser.__ERROR__\n";
        break if _t == BaseParser.__ERROR__
      end while false; self._pos=_p25 if (_t==BaseParser.__ERROR__); end

    if (_t==BaseParser.__ERROR__); break; else as26.add(_t);nil;end
    end; _t=as26

    xs=_t;
    break if _t == BaseParser.__ERROR__
    _t=( "_t=BaseParser.__ERROR__; begin  # or\n#{join(xs, "\n")}#{outdent}end while false\n" );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p27 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Or" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def And:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('And')
          
          ts = Object(nil)

          _t=BaseParser.__ERROR__; begin  # or
    begin; _p29=_pos; _t=nil; begin  # and
      _t=self.indent();
      break if _t == BaseParser.__ERROR__
      as28 = ArrayList.new
      _t=self.trans();
      if (_t!=BaseParser.__ERROR__)
        as28.add(_t)
        while true  # many
        _t=self.trans();
        if (_t==BaseParser.__ERROR__); break; else as28.add(_t);nil;end
        end; _t=as28

      end

      ts=_t;
      break if _t == BaseParser.__ERROR__
      _t=(
        var = genvar
        err = null
        xs = List(ts)
        b = "begin; _p#{var}=_pos; _t=nil; begin  # and\n"
        xs.each do |x|
          if x.kind_of?(DoError)
            err = DoError(x).message
            next
          end
          b = if err.nil?
            "#{b}#{@_}#{x}\n#{@_}break if _t == BaseParser.__ERROR__\n"
          else
            "#{b}#{@_}#{x}\n#{@_}raise SyntaxError.new(\"#{err}\", _pos, _string, _list) if _t == BaseParser.__ERROR__\n"
          end
        end
        outdent();
        "#{b}#{@_}end while false; self._pos=_p#{var} if (_t==BaseParser.__ERROR__); end\n"
    );
      break if _t == BaseParser.__ERROR__
    end while false; self._pos=_p29 if (_t==BaseParser.__ERROR__); end

    break unless _t == BaseParser.__ERROR__

    _t="";
    break unless _t == BaseParser.__ERROR__
  end while false

          _t=_exit(_t)
          BaseParser.__ERROR__.last="And" if (_t==BaseParser.__ERROR__)
          return _t
        end
        def makeMany(x:Object, many1:boolean);
        var = genvar
        b = "as#{var} = ArrayList.new\n"
        if (many1)
          b = "#{b}#{@_}#{x}\n#{@_}if (_t!=BaseParser.__ERROR__)\n#{indent}as#{var}.add(_t)\n"
        end

        b = "#{b}#{@_}while true  # many\n" +
            "#{@_}#{x}\n" +
            "#{@_}if (_t==BaseParser.__ERROR__); break; else as#{var}.add(_t);nil;end\n" +
            "#{@_}end; _t=as#{var}\n"

        if (many1)
          b= "#{b}\n#{outdent}end\n"
        end
        b;
    ;end

        def Many:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Many')
          
          x = Object(nil)

          begin; _p30=_pos; _t=nil; begin  # and
    _t=self.indent();
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.outdent();
    break if _t == BaseParser.__ERROR__
    _t=( makeMany(x, false) );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p30 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Many" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Many1:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Many1')
          
          x = Object(nil)

          begin; _p31=_pos; _t=nil; begin  # and
    _t=self.indent();
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.outdent();
    break if _t == BaseParser.__ERROR__
    _t=( makeMany(x, true)  );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p31 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Many1" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Opt:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Opt')
          
          x = Object(nil)

          begin; _p32=_pos; _t=nil; begin  # and
    _t=self.indent();
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.outdent();
    break if _t == BaseParser.__ERROR__
    _t="#{x}\n#{@_}_t=(_string.nil? ? \"\" : nil) if _t == BaseParser.__ERROR__;";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p32 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Opt" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Not:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Not')
          
          x = Object(nil)

          begin; _p33=_pos; _t=nil; begin  # and
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t="#{@_}#{x}\n_t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__);";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p33 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Not" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Peek:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Peek')
          
          x = Object(nil)

          begin; _p34=_pos; _t=nil; begin  # and
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
      var = genvar
      
      "begin\n#{indent}_l#{var}=_pos\n#{@_}#{x}\n#{@_}self._pos=_l#{var} if (_t!=BaseParser.__ERROR__)\n#{outdent}end\n"
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p34 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Peek" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def List:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('List')
          
          x = Object(nil)

          begin; _p35=_pos; _t=nil; begin  # and
    _t=self.indent();
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.outdent();
    break if _t == BaseParser.__ERROR__
    _t="_t=_listBegin(); if (_t!=BaseParser.__ERROR__)\n#{@_}  #{x}\n#{@_}_listEnd(); end;";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p35 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="List" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def MemoRule:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('MemoRule')
          
          n = b = Object(nil)

          begin; _p36=_pos; _t=nil; begin  # and
    _t=self._any();
    n=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    b=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
      rule_body(n, b, true)
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p36 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="MemoRule" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Rule:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Rule')
          
          n = b = Object(nil)

          begin; _p37=_pos; _t=nil; begin  # and
    _t=self._any();
    n=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    b=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
      rule_body(n, b, false)
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p37 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Rule" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Scope:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Scope')
          
          names = body = Object(nil)

          begin; _p38=_pos; _t=nil; begin  # and
    _t=self._any();
    names=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.indent();
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    body=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.outdent();
    break if _t == BaseParser.__ERROR__
    _t=(
      pre = StringBuilder.new
      post = StringBuilder.new
      l = Object[].cast(names)
      l.each do |_name|
        name = String(_name)
        saved = "__saved_#{name.replace('@', '')}"
        pre.append("#@_#{saved} = #{name}\n")
        post.append("#@_  #{name} = #{saved}\n")
      end
      "#{pre}#{@_}begin\n#{@_}#{body}\n#{@_}ensure\n#{post}#{@_}end\n"
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p38 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Scope" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Parser:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Parser')
          
          p = n = s = xs = Object(nil)

          begin; _p40=_pos; _t=nil; begin  # and
    _t=self._any();
    p=_t;
    break if _t == BaseParser.__ERROR__
    _t=self._any();
    n=_t;
    break if _t == BaseParser.__ERROR__
    _t=self._any();
    s=_t;
    break if _t == BaseParser.__ERROR__
    _t=( @name = String(n); @sname = String(s); nil );
    break if _t == BaseParser.__ERROR__
    as39 = ArrayList.new
    while true  # many
    _t=self.trans();
    if (_t==BaseParser.__ERROR__); break; else as39.add(_t);nil;end
    end; _t=as39

    xs=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
        b = "\nclass #{@name} < #{@sname}\n  def _init;#{build_init};end\n" +
            join(xs) + "\n" + join(@methods) + "\n" +
            "  def _jump(r:string)\n"

        @rules.each do |r|
          b = "#{b}    return #{r}() if (r==\"#{r}\")\n"
        end
        b = b +
            "    super(r)\n" +
            "  end\n" +
            "  def _has(r:string)\n"

        @rules.each do |r|
          b = b + "    return true if r==\"#{r}\"\n"
        end

        b = b +
            "    super(r)\n" +
            "  end\n" +
            "end\n"
        reset
        b
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p40 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Parser" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Method:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Method')
          
          c = Object(nil)

          begin; _p41=_pos; _t=nil; begin  # and
    _t=self._any();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t="  #{c}\n";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p41 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Method" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Field:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Field')
          
          c = Object(nil)

          begin; _p42=_pos; _t=nil; begin  # and
    _t=self._any();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t="  #{c}\n";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p42 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Field" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Package:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Package')
          
          c = Object(nil)

          begin; _p43=_pos; _t=nil; begin  # and
    _t=self._any();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t=( @jpackage = String(c); ""; );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p43 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Package" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Import:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Import')
          
          c = Object(nil)

          begin; _p44=_pos; _t=nil; begin  # and
    _t=self._any();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t=c;
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p44 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Import" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Class:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Class')
          
          q = d = c = Object(nil)

          begin; _p45=_pos; _t=nil; begin  # and
    _t=self._any();
    q=_t;
    break if _t == BaseParser.__ERROR__
    _t=self._any();
    d=_t;
    break if _t == BaseParser.__ERROR__
    _t=self._any();
    c=_t;
    break if _t == BaseParser.__ERROR__
    _t="#{d}\n#{c}\nend";
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p45 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Class" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def Line:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('Line')
          
          ws = x = Object(nil)

          begin; _p46=_pos; _t=nil; begin  # and
    _t=self._any();
    ws=_t;
    break if _t == BaseParser.__ERROR__
    _t=self.trans();
    x=_t;
    break if _t == BaseParser.__ERROR__
    _t=( ws.toString + x.toString );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p46 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="Line" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def File:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('File')
          
          xs = Object(nil)

          begin; _p48=_pos; _t=nil; begin  # and
    as47 = ArrayList.new
    while true  # many
    _t=self.trans();
    if (_t==BaseParser.__ERROR__); break; else as47.add(_t);nil;end
    end; _t=as47

    xs=_t;
    break if _t == BaseParser.__ERROR__
    _t=(
        "# generated by mmeta on #{Date.new}\n" +
        "# do not modify, instead edit original .mmeta file\n" +
        "import java.util.ArrayList\n" +
        "import java.util.Date\n" +
        "import java.util.List\n" +
        "import java.util.EnumSet\n" +
        (@embedded ? "" : "import jmeta.*;\n") + join(xs)
    );
    break if _t == BaseParser.__ERROR__
  end while false; self._pos=_p48 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="File" if (_t==BaseParser.__ERROR__)
          return _t
        end
      
        def start:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('start')
          
          r = Object(nil)

          begin; _p49=_pos; _t=nil; begin  # and
    _t=self.destruct();
    r=_t;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=self.end();
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
    _t=r;
    raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__
  end while false; self._pos=_p49 if (_t==BaseParser.__ERROR__); end

          _t=_exit(_t)
          BaseParser.__ERROR__.last="start" if (_t==BaseParser.__ERROR__)
          return _t
        end
        def unescape(s:String);
      sb = StringBuilder.new
      i = 0
      while i < s.length
        if s.charAt(i) == 92 # ?\\
          i += 1
          c = s.substring(i, i + 1)
          if c.equals("n")
            sb.append("\n")
          elsif c == "s"
            sb.append("\s")
          elsif c == "r"
            sb.append("\r")
          elsif c == "t"
            sb.append("\t")
          elsif c == "v"
            sb.append("\v")
          elsif c == "f"
            sb.append("\f")
          elsif c == "b"
            sb.append("\b")
          elsif c == "a"
            sb.append("\a")
          elsif c == "e"
            sb.append("\e")
          else
            sb.append(c)
          end
        else
          sb.append(s.charAt(i))
        end
        i += 1
      end
      return sb.toString.toCharArray
    ;end
  def compile_literal_string(_s:Object);
      s = unescape(String(_s))
      if s.length == 0
        "_t = ''\n"
      else
        var = "_p#{genvar}"
        sb = StringBuilder.new("#{@_}_t = BaseParser.__ERROR__\n")
        sb.append("#{@_}#{var} = _pos\n")
        sb.append("#{@_}begin\n")
        sb.append("#{@_}  break if #{var} + #{s.length} > @chars.length\n")
        s.each do |c|
          sb.append("#{@_}  break unless @chars[#{var}] == #{c}\n")
          sb.append("#{@_}  #{var} += 1\n")
        end
        sb.append("#{@_}  _t = \"#{_s}\"; self._pos = #{var}\n")
        sb.append("#{@_}end while false\n")
        sb.toString
      end
    ;end
  def lookup_token(name:Object);
      @tokens ||= ArrayList.new
      index = @tokens.indexOf(name)
      if index == -1
        index = @tokens.size
        @tokens.add(name)
      end
      return index
    ;end
  def lookup_range(first:Object, last:Object);
      key = "#{first},#{last}"
      val = String(@ranges.get(key))
      if val.nil?
        val = "@_trange#{@ranges.size}"
        @ranges.put(key, val)
      end
      val
    ;end
  def build_init();
      code = StringBuilder.new("\n@chars = _chars\nsuper()\n")
      @ranges.keySet.each do |key|
        tokens = String(key).split(",")
        first = tokens[0]
        last = tokens[1]
        name = @ranges.get(key)
        code.append("#{name} = EnumSet.range(Tokens.t#{first}, Tokens.t#{last})\n")
      end
      code.toString
    ;end
  def rule_body(n:Object, b:Object, force_memo:boolean);
      @rules.add(n)
      if @left_recursion
        rfunc = "_retrieve"
        loop_start = "    begin"
        loop_end = "end while (_t==BaseParser.__GROW__); "
      else
        rfunc = "_sretrieve"
        loop_start = ""
        loop_end = ""
      end

      if force_memo || @auto_memo
        find = "_t=#{rfunc}(\"#{@name}.#{n}\"); return _exit(_t) if (_t!=BaseParser.__NOT_MEMOIZED__)"
        save = "_memoize(\"#{@name}.#{n}\", _start, _t)"
      else
        find = ""
        save = "_t"
      end
      "
        def #{n}:Object
          _t = Object(nil); _start = _pos; _real_start = -1
          _enter('#{n}')
          #{find}
          #{localsAsInit}#{loop_start}
          #{b}
          _t=_exit(#{save})
          #{loop_end}BaseParser.__ERROR__.last=\"#{n}\" if (_t==BaseParser.__ERROR__)
          return _t
        end
      "
    ;end


  def _jump(r:string)
    return destruct() if (r=="destruct")
    return trans() if (r=="trans")
    return HList() if (r=="HList")
    return HConcat() if (r=="HConcat")
    return HStr() if (r=="HStr")
    return HLit() if (r=="HLit")
    return Node() if (r=="Node")
    return Error() if (r=="Error")
    return Set() if (r=="Set")
    return Str() if (r=="Str")
    return Sym() if (r=="Sym")
    return App() if (r=="App")
    return Dot() if (r=="Dot")
    return SAct() if (r=="SAct")
    return Act() if (r=="Act")
    return Pred() if (r=="Pred")
    return SynPred() if (r=="SynPred")
    return Token() if (r=="Token")
    return TokenRange() if (r=="TokenRange")
    return TLit() if (r=="TLit")
    return Or() if (r=="Or")
    return And() if (r=="And")
    return Many() if (r=="Many")
    return Many1() if (r=="Many1")
    return Opt() if (r=="Opt")
    return Not() if (r=="Not")
    return Peek() if (r=="Peek")
    return List() if (r=="List")
    return MemoRule() if (r=="MemoRule")
    return Rule() if (r=="Rule")
    return Scope() if (r=="Scope")
    return Parser() if (r=="Parser")
    return Method() if (r=="Method")
    return Field() if (r=="Field")
    return Package() if (r=="Package")
    return Import() if (r=="Import")
    return Class() if (r=="Class")
    return Line() if (r=="Line")
    return File() if (r=="File")
    return start() if (r=="start")
    super(r)
  end
  def _has(r:string)
    return true if r=="destruct"
    return true if r=="trans"
    return true if r=="HList"
    return true if r=="HConcat"
    return true if r=="HStr"
    return true if r=="HLit"
    return true if r=="Node"
    return true if r=="Error"
    return true if r=="Set"
    return true if r=="Str"
    return true if r=="Sym"
    return true if r=="App"
    return true if r=="Dot"
    return true if r=="SAct"
    return true if r=="Act"
    return true if r=="Pred"
    return true if r=="SynPred"
    return true if r=="Token"
    return true if r=="TokenRange"
    return true if r=="TLit"
    return true if r=="Or"
    return true if r=="And"
    return true if r=="Many"
    return true if r=="Many1"
    return true if r=="Opt"
    return true if r=="Not"
    return true if r=="Peek"
    return true if r=="List"
    return true if r=="MemoRule"
    return true if r=="Rule"
    return true if r=="Scope"
    return true if r=="Parser"
    return true if r=="Method"
    return true if r=="Field"
    return true if r=="Package"
    return true if r=="Import"
    return true if r=="Class"
    return true if r=="Line"
    return true if r=="File"
    return true if r=="start"
    super(r)
  end
end
