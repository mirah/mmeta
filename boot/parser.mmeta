# copyright 2009 ActiveVideo; license: MIT; see license.txt
package mmeta;
import java.util.*;

public parser MMetaParser {
    def oneOf() {
      chars = String(_pop())
      return _char(chars)
    }

    fromTo x=_ y=_: str(x) (~str(y) _)* str(y) ;
    sp            : super.sp | fromTo("//","\n") | fromTo("/*","*/") | fromTo("#", "\n") ;
    ws            : (sp|nl)* ;

    listOf e=_ s=_: .f=apply(e) rs=(.str(s) .apply(e))*                 { [f] + rs }
                  | empty                                               { [] } ;

    nameFirst     : "_" | letter ;
    nameRest      : nameFirst | digit ;
    name          : f=nameFirst rs=nameRest*                            { join(concat([f], rs)) } ;
    rulename      : ~k("def") name;
    varname       : p=("@"|{""}) n=name { "#{p}#{n}" };

    hex      : oneOf("0123456789abcdefABCDEF");
    echar         : //"\\u" u1=hex u2=hex u3=hex u4=hex                   { char(Integer.parseInt(""+u1+u2+u3+u4, 16)) }
                  | "\\"! c=_                                           { "\\#{c}"; }
                  | _ ;
    tsString      : "\"" xs=(~"\"" echar)* "\""                         { join(xs) } ;

    dollar        : "${" xs=cbraces* "}"                                { "\"+#{join(xs)}+\"" }
                  | "$" n=name                                          { "\"+#{n}+\""        } ;
    dollarstring  : "\"" xs=(~"\"" (dollar|echar))* "\""                { join(xs) } ;

    string        : s=tsString                                          { [:Str, s] } ;
    number        : sign=("-"|"+"|empty) ds=digit+                      { ["HLit", "#{sign}#{join(ds)}"] } ;
    symbol        : ("'"!|":") (s=name
                               | "'" c=(~"'" _)+ "'" s={join(c)}) { [:Sym, s] } ;
    k keyword=_   : str(keyword) ~(nameFirst|digit)                     { keyword } ;

    error         : "!" msg=(dollarstring|empty)                        { [:Error, msg] } ;
    any           : "_"                                                 { [:App, :_any] } ;
    wsdot         : "."                                                 { [:Dot] } ;

    args          : "(" ! as=listOf(:simplehost,",") .")"               { as }
                  | empty                                               { [] } ;
    application   : "super."! r=name as=args                            { [:App, :super, r] + as }
                  | r=name as=args                                      { [:App, r] + as } ;

    fname         : t=(x=name "." { "#{x}." })* n=name {"#{join(t)}#{n}"};
    parens        : "(" x=(parens | ~oneOf("()") _)* ")" {"(#{join(x)})"};

    rewrite_expr  : . n=name p=parens                                   { ["HLit", "#{n}#{p}"] }
                  | . "^(" . n=name c=rewrite_expr . oneOf("*+") . ")"  { [:Node, n, c]}
                  | . "^(" . n=name c=rewrite_expr* . ")"               { [:Node, n, [:HList] + c]}
                  | ."$" n=name                                         { [:TLit, n] }
                  | .s=tsString                                         { [:HStr, s] }
                  | . n=name                                            { [:HLit, n] }
                  | ."[" xs=listOf(:rewrite_expr, ",") ."]"             { [:HList] + xs };

    simplehost    : rs=simplehost1 ."+" .ls=simplehost                  { [:HConcat, rs, ls] }
                  | x=simplehost1                                       { x } ;
    simplehost1   : "[" xs=listOf(:simplehost,",") ."]"                 { [:HList] + xs }
                  | .n=number                                           { n }
                  | .("'"!|":") s=name                                  { [:HStr, s] }
                  | .s=tsString                                         { [:HStr, s] }
                  | ."@" n=name                                         { ["HLit", "@#{n}"] }
                  | .n=name                                             { [:HLit, n] } ;
    cbraces       : "{" xs=cbraces* "}"                                 { "{"+ join(xs) +"}" }
                  | ~"}" _ ;
    semAction     : "{" . s=simplehost ."}"                             { [:SAct, s] }
                  | "{"!  xs=cbraces*    "}"                            { ["Act", "#{join(xs)}"] }
                  | "->"! s=rewrite_expr                                 { [:SAct, s] };
    semPred       : "?{"! xs=cbraces*    "}"                            { ["Pred", "#{join(xs)}"] } ;
    synPred       : ."(" p=expr .")" ."=>" e=expr4 t=synPredTail        { [:SynPred, [:Peek, p], e, t] };
    synPredTail   : ."|" (synPred | expr4)
                  | {[:Pred, "false"]};
    token         : "$" n=name                                          { n };
    tokens        : a=token (.".." . b=token                            { [:TokenRange, a, b]}
                            |                                           { [:Token, a]}
                            );

    expr          : xs=listOf(:expr4,"|")                               { [:Or]  + xs  } ;
    expr4         : xs=expr3*                                           { [:And] + xs  } ;
    optIter x=_   : "*"                                                 { [:Many,  x]  }
                  | "+"                                                 { [:Many1, x]  }
                  | "?"                                                 { [:Opt,   x]  }
                  | empty                                               { x            } ;
    expr3         : .n=name ."="! .e=expr2 x=optIter(e)                 { [:Set, n, x] }
                  | .e=expr2 x=optIter(e)                               { x            } ;
    expr2         : "~"! x=expr2                                        { [:Not,  x]   }
                  | "&"! x=expr1                                        { [:Peek, x]   }
                  | expr1 ;
    expr1         : wsdot | any | error | semPred | semAction | application | tokens
                  | x=(k("null")|k("true")|k("false"))                  { [:HLit, x] }
                  | string | symbol | number
                  | "["! .x=expr ."]"                                    { [:List, x] }
                  | synPred
                  | "("! .x=expr .")"                                    { x } ;

    rule          : ."@Memo" &(.n=rulename) .x=rulePart(n)! xs=(.";" .rulePart(n))* .";"  { [:MemoRule, n, [:Or, x] + xs ] }
                  | &(.n=rulename) .x=rulePart(n)! xs=(.";" .rulePart(n))* .";"  { [:Rule, n, [:Or, x] + xs ] } ;
    rulePart rn=_ : .n=name ?{ n.equals(rn) } !
                    ( s=(.k("scope")"(" l=listOf(:varname, ",") .")") c=ruleStuff { [:Scope, l, c] }
                    | ruleStuff
                    );
    ruleStuff     : .b1=expr4 (.":"! .b2=expr                                { [:And, b1, b2] }
                              | empty                                        { b1 }
                              ) ;

    // java parsing support
    qualifiers: qs=(.k("public")|.k("private")|.k("final")|.k("static")|.k("abstract"))+
    {
        join(qs, " ")
    } ;
    method    : "def" . s=("self." | {""})! n=name! (."(" as=(~")" _)* ")"| {""})! ."{" bs=cbraces* "}"
    {
        ["Method", "#{s}#{n}", "#{join(as)}", "#{join(bs)}"]
    }
    ;
    jimport   : stm=k("import") ! xs=(~oneOf(";\n") _)* ";"?
    {
        ["Import", "#{stm}#{join(xs)}"]
    } ;
    jpackage  : stm=k("package") ! xs=(~";" _)* ";"
    {
        ["Package", "#{stm}#{join(xs)}"]
    } ;
    classdef  : q=qualifiers . k("class") ! xs=(~"{" _)* "{" bs=cbraces* "}"
    {
        ["Class", q, " class #{join(xs)}", "#{join(bs)}"]
    } ;

    ruleMethod: .method | .rule ;
    parser    : .p=(k("public")|empty) .k("parser") ! .n=name .sn=((k("extends") | ."<") .name|empty {"BaseParser"})
                ."{" rs=ruleMethod* ."}"
                p={ [:Parser, p, n, sn] + rs } !
                {
                   if (Boolean.getBoolean("mmeta.optimize.debug"))
                     System.out.println("Before:\n" + BaseParser.print_r(p));
                   end
                   MMetaOptimizer.new().parse(p, "optimizeGrammar");
                } ;

    line      : p=. l=(parser|jpackage|jimport|classdef)  { ["Line", "#{join(p)}", l] } ;
    file      : ! ls=line* . end                 { [:File] + ls } ;
    start     : file ;
}

parser MMetaPass {
  def init {
    @changed = false
  }
  def changed {
    @changed
  }
  def changed_set(value:boolean) {
    @changed = value
  }
    setChanged:  {@changed = true; nil;} ;

    destruct: r=_ ?{ hasRule(r) } ! x=apply(r) end { x } ;
    trans   : [ x=destruct ]                             { x }
            | _                                                ;

    Or       xs=trans*            { [:Or]  + xs   } ;
    And      xs=trans*            { [:And] + xs   } ;
    Not      x=trans              { [:Not,   x]   } ;
    Many     x=trans              { [:Many,  x]   } ;
    Many1    x=trans              { [:Many1, x]   } ;
    Peek     x=trans              { [:Peek,  x]   } ;
    List     x=trans              { [:List,  x]   } ;
    Set      n=_ x=trans          { [:Set,  n, x] } ;
    Rule     n=_ x=trans          { [:Rule, n, x] } ;
    SynPred  xs=trans*            { [:SynPred] + xs };

    start: r=destruct end { r }
         | r=_ end        { r }
         | r=_* end       { r } ;
}

parser MMetaAndOrOpt extends MMetaPass {
    And  x=trans end          setChanged { x } ;
    And xs=transInside(:And)             { [:And] + xs } ;
    Or   x=trans end          setChanged { x } ;
    Or  xs=transInside(:Or)              { [:Or] + xs  } ;

    transInside s=_ : [ sym(s) xs=transInside(s) ] ys=transInside(s) setChanged { xs + ys  }
                    |   x=trans xs=transInside(s)                               { [x] + xs }
                    |                                                           { []       } ;
}

parser MMetaOptimizer {
    optimizeGrammar: ! :Parser p=_ n=_ sn=_ rs=optimizeRule* end
                     x={ [:Parser, p, n, sn] + rs }
                     {
                       if (Boolean.getBoolean("mmeta.optimize.debug"))
                         System.out.println("Opt:\n" + BaseParser.print_r(x))
                       end
                       x
                     } ;
    optimizeRule:    r=_ {
        MMetaAndOrOpt opt = MMetaAndOrOpt.new()
        begin
            opt.changed = false
            r = opt.parse(r)
        end while (opt.changed)
        r
    } ;
}

