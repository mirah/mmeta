import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.InputStream
import java.io.FileInputStream
import java.util.ArrayList
import java.util.List
import java.util.LinkedList
import java.util.Collections
import jmeta.Ast

public class HeredocContext {
  def initialize(node:Object)
    @node = Ast(node)
    @id = String(@node.get(1))
    @type = '"'
    if @id.startsWith("-")
      @id = @id.substring(1)
      @no_indent = false
    else
      @no_indent = true
    end
    if @id.startsWith("'")
      @type = "'"
      @id = @id.substring(1, @id.length - 1)
    elsif @id.startsWith('"')
      @id = @id.substring(1, @id.length - 1)
    end
  end

  def id
    @id
  end

  def node
    @node
  end

  def no_indent
    @no_indent
  end

  def type
    @type
  end
}

parser MirahParser {
  digits x=_ : a = oneOf(x) b=("_" c=oneOf(x) {c})*
                               d={[a] + b} { join(d) };
  rlistOf r=_: h=apply(r) t=(."," apply(r))* { [h] + t };
  listOf e=_: rlistOf(e)
              | empty                                               { ArrayList.new } ;

  ws: (oneOf(" \t\f\r\v") | "\\" nl | comment)*;
  comment: "#" (~"\n" _)*;
  start: ! prog=compstmt . end heredoc -> ^(Script prog);
  compstmt: terms* a=(s=statement terms+ {s})*
            b=statement?
            {addToBlock(a, b)};

  bodystmt: b=compstmt r=Rescue? e=Else? f=Ensure? {
    node = b
    if r != nil
      node = build_node('Rescue', [b, r, e], _start, _pos)
    elsif e != nil
      # Warning?
      node = addToBlock(b, e)
    end
    unless f.nil?
      end_pos = Ast(f).end_position
      node ||= @nil
      node = build_node('Ensure', [node, f], _start, _pos)
    end
    node || @nil
  };

  term: . (";" | nl);
  terms: . (";" | nl) (. ";")*;

  nl: "\n" heredoc;

  statement: expr;

  value v=_ : {checkExpression(v)};

  expr: command_call
      | arg;

  # Node:command - fcall/call/yield/super [!null]
  command: op=operation a=command_args b=cmd_brace_block?-> ^(FCall op a b)
         | t=value(primary) (."."|"::") op=operation2 a=command_args b=cmd_brace_block?-> ^(Call op t a b)
         | k(:super) a=command_args -> ^(Super a+)
         | k(:yield) a=command_args -> ^(Yield a+);

  # Node:command - call with or without block on end [!null]
  command_call: command
              | block_command
              | k(:return) a=call_args -> ^(Return a+);
              # | k(:break) a=call_args -> ^(Break a+)
              # | k(:next) a=call_args -> ^(Next a+)

  # Node:block_command - A call with a block (foo.bar {...}, foo::bar {...}, bar {...}) [!null]
  block_command: c=block_call (."."|"::") op=operation2 a=command_args
                   -> ^(Call op c a)
               | block_call;

  primary scope(@BEG)
         : k(:begin)! b=bodystmt k(:end) -> ^(Begin b)
         | . "(" e=expr . ")" { e }
         | . "(" e=compstmt . ")" {
           unless e.nil?
             ae = Ast(e)
             ae.start_position = pos(_start)
             ae.end_position = pos(_pos)
           end
           e
         }
         | a=value(primary) "::" b=constant ~(paren_args|call_args|assignment_op) -> ^(Colon2Const a b)
         | colon3 c=constant ~assignment_op -> ^(Colon3 c)
         | isBEG . "[" . "]" -> ^(ZArray)
         | isBEG . "[" a=args trailer . "]" -> ^(Array a+)
         | . "{" . "}" -> ^(Hash)
         | . "{" a=listOf(:assoc) trailer . "}" -> ^(Hash a+)
         | k(:yield) . "(" . ")" -> ^(Yield)
         | k(:yield) . "(" a=call_args . ")" -> ^(Yield a+)
         | k(:yield) -> ^(Yield)
         | ."!" ."(" .")" -> ^(Call "!" ^(Nil))
         | ."!" ."(" e=value(expr) .")" -> ^(Call "!" e)
         | k(:if)! cond=value(expr) Then body=compstmt tail=if_tail k(:end)
           -> ^(If cond body tail)
         | k(:unless)! cond=value(expr) Then body=compstmt tail=Else? k(:end)
           -> ^(If cond tail body)
         | k(:while)! cond=value(expr) Do body=compstmt k(:end) {body ||= @nil}
           -> ^(While cond body)
         | k(:until)! cond=value(expr) Do body=compstmt k(:end) {body ||= @nil}
           -> ^(Until cond body)
         # | k(:case)! val=(value(expr))? terms? body=case_body k(:end)
         #   -> ^(Case val body)
         # TODO is this too restrictive?
         | k(:for) var=variable k(:in)! list=value(expr) Do body=compstmt k(:end)
           -> ^(For var body list)
         | k(:class) . "<<"! BEG e=expr  # Should this just allow k(:self)?
           term b=compstmt k(:end) {b ||= @nil}
           -> ^(SClass e b)
         | k(:class)! n=cpath s=superclass
           b=compstmt  # JRuby has bodystmt, but that doesn't make much
                       # sense for mirah. Maybe rescuing exceptions
                       # in the static initializer?
           k(:end) {b ||= @nil}
           -> ^(Class n b s)
         # | module
         | Def k(:self)! dot_or_colon name=fname args=f_arglist body=bodystmt k(:end)
           -> ^(DefStatic name args body)
         | Def! name=fname args=f_arglist body=bodystmt k(:end)
           -> ^(Def name args body)

         # TODO get do blocks to bind in the right place.
         # | op=operation iter=brace_block -> ^(FCall op nil iter)
         # | method_call brace_block

         | method_call

         # | k(:lambda) lambda

         | k(:break) -> ^(Break)
         | k(:next) -> ^(Next)
         | k(:redo) -> ^(Redo)
         | k(:retry) -> ^(Retry)
         | k(:return) -> ^(Return ^(Nil))
         | literal
         | memo(:string)
         | regexp
         | variable;

  f_arglist: ."("! a=f_args .")" BEG {a}
           | a=f_args term {a};

  f_args: req=f_arg! opt=(."," f_optarg)? rest=(."," f_rest_arg)? req2=(."," f_arg)? block=(."," f_block_arg)?
            -> ^(Arguments req opt rest req2 block)
        | opt=f_optarg! rest=(."," f_rest_arg)? req=(."," f_arg)? block=(."," f_block_arg)?
            -> ^(Arguments nil opt rest req block)
        | rest=f_rest_arg! req=(."," f_arg)? block=(."," f_block_arg)?
            -> ^(Arguments nil nil rest req block)
        | block=f_block_arg -> ^(Arguments nil nil nil nil block)
        | -> ^(Arguments nil nil nil nil nil);

  f_bad_arg: &constant !"formal argument not a constant" ?{false}
           | &ivar !"formal argument not an instance variable" ?{false}
           | &cvar !"formal argument not a class variable" ?{false};

  f_norm_arg: f_bad_arg
            | l=label BEG t=value(primary) n={List(l).get(1)} { [n, t] }
            | n=identifier { [n, nil] };

  f_arg_item: ~f_opt n=f_norm_arg -> ^(RequiredArgument n+);
            # | ."(" f_margs .")"

  f_arg: rlistOf(:f_arg_item);

  f_opt: n=f_norm_arg ."="! v=arg_value l={ n + [v] }-> ^(OptArg l+);
  f_optarg: rlistOf(:f_opt);

  f_rest_arg: ."*" n=f_norm_arg -> ^(RestArg n+)
            | ."*" -> ^(UnnamedRestArg);

  f_block_arg: ."&" n=f_norm_arg ."=" !"nil" k(:nil) -> ^(OptBlockArg n+)
             | ."&"! n=f_norm_arg -> ^(BlockArg n+);

  block_arg: ."&" v=arg_value -> ^(BlockPass v);

  method_call scope(@BEG)
             : op=operation a=paren_args -> ^(FCall op a nil)
             | t=value(primary) ."." op=operation2 a=opt_paren_args -> ^(Call op t a)
             | t=value(primary) "::" op=operation2 a=paren_args -> ^(Call op t a)
             | t=value(primary) "::" op=operation3 ~assignment_op -> ^(Call op t nil)
             | t=value(primary) (."."|"::") a=paren_args -> ^(Call "call" t a)
             | k(:super) a=paren_args -> ^(Super a+)
             | k(:super) -> ^(ZSuper)
             | t=value(primary) ."[" a=call_args? ."]" ~assignment_op -> ^(Call "[]" t a);

  # :brace_block - [!null]
  cmd_brace_block: {__ERROR__};
  brace_block: ."{" p=block_param? b=compstmt ."}" -> ^(Iter p b)
             | k(:do) p=block_param? b=compstmt k(:end) -> ^(Iter p b);
  block_param: {__ERROR__};
  block_call: {__ERROR__};

  paren_args: ."("! c=call_args? .")" {c.nil? ? Object(ArrayList.new) : c};
  opt_paren_args: paren_args | ~(call_args | assignment_op) { nil };

  maybe_rescue: a=arg k(:rescue) b=value(arg)
                -> ^(Rescue a [^(RescueClause [] nil b)] nil)
              | arg;

  assign lhs=_ rhs=_ : { n=Ast(Ast(lhs).clone); n.add(rhs); n };

  arg: l=lhs ."=" r=maybe_rescue assign(l, r)
     | l=var_lhs ."&&=" r=arg
       b=assign(l, r)
       -> ^(If gettable2(l) b null)
     | l=var_lhs ."||=" r=arg
       b=assign(l, r)
       -> ^(If gettable2(l) null b)
     | l=var_lhs op=assignment_op r=arg
       b= -> ^(Call op gettable2(l) [r])
       assign(l, b)
     | t=value(primary) ."[" a=call_args? ."]" op=assignment_op v=arg
       -> ^(OpElemAssign t op a v)
     | value(primary) "::" constant assignment_op arg
       !"constant re-assignment prohibited" ?{false}
     | t=value(primary) (."."|"::") f=identifier op=assignment_op v=arg
       -> ^(OpAssign t f op v)
     | colon3 constant assignment_op arg
       !"constant re-assignment prohibited" ?{false}
     # ranges?
     | c=arg ."?" t=arg . nl? .":" e=arg
       -> ^(If c t e)
     | value(primary);

  arg_value: a=arg {checkExpression(a)};

  trailer: . ("," | nl)?;
  operation: constant | identifier | fid;
  operation2: constant | identifier | fid | op;
  operation3: fid | ~constant identifier | op;
  dot_or_colon: . ("." | "::");

  # This marks the beginning of an expression. It must be used inside
  # a rule with scope(@BEG).
  BEG: {@BEG = _pos;nil};
  isBEG: ( ?{_pos == @BEG} | ?{Integer.valueOf(0).equals(col())}
         | ?{@begchars.indexOf(_rpeek) >= 0} | oneOf(" \t\f\r\v"));
  colon3: isBEG . "::";

  splat: ."*" v=arg_value s= -> ^(Splat v) { [s] };
  args: l=rlistOf(:arg_value) (."," s=splat {l+s} | { l })
      | splat;

  call_assocs scope(@BEG): l=rlistOf(:assoc) -> ^(Hash l+);
  call_args: c=command { [c] }
           | a=args h=(."," call_assocs)? b=(.","! block_arg)? l={ a }
             ( ?{h} l={ a + [h] } )?
             ( ?{b} l={ l + [b] } )?
             { l }
           | h=call_assocs b=(.","! block_arg)? l={ [h] }
             ( ?{b} l={l+[b]} )?
             { l }
           | b=block_arg { [b] };
  command_args: ~(."("|character) call_args;

  assignment_op: . op=("<<="|"<<<="|"-="|"%="|"||="|"|="|"+="|"/="|"**="
                      |"*="|"&&="|"&="|"^="|">>="|"=" ~oneOf("~=>") {"="})
                 {"#{String(op).substring(0, String(op).length - 1)}"};

  lhs: t=value(primary) ."[" k=call_args? ."]" -> ^(AttrAssign "[]=" t k)
     | t=value(primary) (."."|"::") n=constant -> ^(ConstAssign ^(Colon2Const t n))
     | colon3 n=constant -> ^(ConstAssign ^(Colon3 n))
     | t=value(primary) (."."|"::") n=identifier l={ArrayList.new} -> ^(AttrAssign "#{n}=" t l)
     | var_lhs;
  var_lhs: n=cvar -> ^(ClassVarAssign n)
         | n=ivar -> ^(InstVarAssign n)
         | n=constant -> ^(ConstAssign n)
         | n=identifier -> ^(LocalAssign n);

  assoc: a=arg_value . "=>" b=arg_value -> ^(Assoc a b)
       | l=label BEG v=arg_value -> ^(Assoc l v);

  label: . n=identifierChar+ ":" ~":" -> ^(Symbol join(n));

  literal: numeric | symbol;

  numeric: floatLiteral | fixnum;

  constant: . &upperCase ~reswords ~label h=upperCase t=identifierChar* {"#{h}#{join(t)}"};
  identifier: . &identifierChar ~reswords ~label n=identifierChar+ {join(n)};
  cvar: . "@@" n=identifierChar+ {join(n)};
  ivar: . "@" n=identifierChar+ {join(n)};
  fid: . t=identifierChar+ p=oneOf("?!") ~"=" {"#{join(t)}#{p}"};
  fname: . n=identifierChar+ t=( b=oneOf("!?") ~"=" {b}
                               | "=" ~(oneOf("~>=")|"\n>") {"="}
                               | {""})
           {"#{join(n)}#{t}"}
       | op;

  op: . ( "<=>" | "===" | "==" | "=~" | "!~" | "<=" | ">=" | "<<<"
        | "<<" | ">>" | "!=" | "**" | "[]=" | "[]" | "+@" | "-@"
        | oneOf("&|^<>+-*/%!~")
        );

  cname: c=constant -> ^(Constant c)
       | &identifier !"class/module name must be CONSTANT" ?{false};

  # JRuby allows primary_value in cpath. Do we want that?
  cpath: colon3 n=cname -> ^(Colon3 n)
       | a=(n=cname "::" {n})* b=cname
         (?{List(a).size == 0} {b} |
          names={a+[b]}-> ^(Colon2 names+));

  superclass: term {nil}
            | ."<" c=cpath term  # Should this be expr_value instead of cpath?
              {c};

  variable: k(:nil)                                   -> ^(Nil)
          | k(:self)                                  -> ^(Self)
          | k(:true)                                  -> ^(True)
          | k(:false)                                 -> ^(False)
          | v=cvar                                    -> ^(ClassVar v)
          | v=ivar                                    -> ^(InstVar v)
          | n=fid                                     -> ^(FCall n)
          | c=constant                                -> ^(Constant c)
          | n=identifier                              -> ^(Identifier n);

  symbol: . ":" ~":"! v=("@@" | "@" | {""}) ! n=identifierChar+ -> ^(Symbol join(concat([v], n)));

  string: character
        | strings=string1+ {stringConcat(strings)};

  string1: . "'"! s=squote_contents* "'" -> ^(String join(s))
         | . "\"\"" -> ^(String "")
         | . "\"" s=dquote_contents "\"" {s}
         | . "\""! c=(dquote_contents | str_ev)* "\"" -> ^(DString c+)
         | . "<<" x=heredoc_id n= -> ^(Heredoc x) { @heredocs.addLast(HeredocContext.new(n)); n }
         ;

  regexp: ."/" c=(regexp_contents | str_ev)* "/" options=letter*
          -> ^(Regex c join(options));

  str_ev: "\#@@"! n=identifierChar+ -> ^(EvString ^(ClassVar join(n)))
        | "\#@"! n=identifierChar+ -> ^(EvString ^(InstVar join(n)))
        | "\#{"! c=compstmt "}" -> ^(EvString c);

  heredoc_id: "-"? ( "\""! identifierChar+ "\""
                   | "'"! identifierChar+ "'"
                   | identifierChar+
                   ) {text(_start, _pos)};

  squote_contents: "\\\\" { "\\" } | "\\'" { "'" } | ~"'" _;
  dquote_contents: c=(escape | ~("\#{" | "\#@" | "\"")_)+ -> ^(String join(c));
  regexp_contents: c=(re_escape | ~("\#{" | "\#@" | "/")_)+ -> ^(String join(c));

  squote_heredoc id=_ : s=(~heredoc_marker(id) _)* heredoc_marker(id) {join(s)};
  dquote_heredoc id=_ : n=( str_ev
                          | s=(~(heredoc_marker(id) | "\#{" | "\#@") _)+
                            -> ^(String join(s))
                          )* heredoc_marker(id) {n};

  heredoc_marker c=_ : ?{"\n".equals(text(_pos - 1, _pos))}
                       ( ?{HeredocContext(c).no_indent}
                       | oneOf(" \t\f\r\v")*
                       ) {_str(HeredocContext(c).id)} "\n";

  character: . "?" e=escape -> ^(Character getCodePoint(e))
           | . "?" c=codepoint -> ^(Character getCodePoint(c));

  escape: unicode_escape
        | "\\"! ("n" {"\n"}
                |"s" {"\s"}
                |"r" {"\r"}
                |"t" {"\t"}
                |"v" {"\v"}
                |"f" {"\f"}
                |"b" {"\b"}
                |"a" {"\a"}
                |"e" {"\e"}
                |"\n" {""}
                |codepoint
                );

  unicode_escape: "\\" ( "\n" {""}
                       | "\\" {"\\"}
                       | a=oneOf(@OCTAL) b=oneOf(@OCTAL) c=oneOf(@OCTAL)
                         {String.new(Character.toChars(Integer.parseInt("#{a}#{b}#{c}", 8)))}
                       |"x"! a=oneOf(@HEX) b=oneOf(@HEX)
                         {String.new(Character.toChars(Integer.parseInt("#{a}#{b}", 16)))}
                       |"u"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                         {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}", 16)))}
                       |"U"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                             c5=oneOf(@HEX) c6=oneOf(@HEX) c7=oneOf(@HEX) c8=oneOf(@HEX)
                         {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}#{c5}#{c6}#{c7}#{c8}", 16)))}
                       );

  re_escape: unicode_escape
           | "\\"! c=codepoint {"\\#{c}"};

  Then: . term? k(:then) | . term;
  Ensure: k(:ensure)! compstmt;
  Else: k(:else)! compstmt;
  Do: k(:do) | . term;
  Def: k(:def) ~oneOf("?!");

  if_tail: Else
         | k("elsif")! cond=value(expr) Then body=compstmt tail=if_tail
           -> ^(If cond body tail)
         | {nil};

  Rescue: (k("rescue")! c=listOf(:constant) (. "=>" . n=identifier)?
           Then b=compstmt -> ^(RescueClause c n b))+;

  fixnum: . n=( "0"! ( oneOf("xX") d=digits(@HEX)+ { parseInt(join(d), 16) }
                  | oneOf("dD") d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
                  | oneOf("oO") d=digits(@OCTAL)+ { parseInt(join(d), 8) }
                  | oneOf("bB") d=digits(@BINARY)+ { parseInt(join(d), 2) }
                  | d=digits(@OCTAL)* { parseInt("0" + join(d), 8) }
                  )
            | d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
            ) -> ^(Fixnum n);

  floatLiteral: . f=(i=digits(@DECIMAL)+
                     f=("." digits(@DECIMAL)+ | { ArrayList.new })
                     e=(oneOf("eE") digits(@DECIMAL)+ | { ArrayList.new })
                     ?{List(f).size() + List(e).size() > 0}
                     s={i+["."]+f+["E"]+e}
                     { Double.new(join(s)) }
                    ) -> ^(Float f);

  # Left recursion clears memoization of some values, but heredocs
  # can only be processed once. This rule forces memoization.
  memo rule=_ : position = {Integer.valueOf(_pos)}
                ( {@memo.get(position) || __ERROR__}
                | v=apply(rule) { @memo.put(position, v); v });

  reswords: k(:__LINE__)|k(:__FILE__)|k(:__ENCODING__)|k(:BEGIN)|k(:END)|k(:alias)
          | k(:and)|k(:begin)|k(:break)|k(:case)|k(:class)|k(:def)|k(:defined)|k(:do)
          | k(:else)|k(:elsif)|k(:end)|k(:ensure)|k(:false)|k(:for)|k(:in)|k(:module)
          | k(:next)|k(:nil)|k(:not)|k(:or)|k(:redo)|k(:rescue)|k(:retry)|k(:return)
          | k(:self)|k(:super)|k(:then)|k(:true)|k(:undef)|k(:when)|k(:yield)|k(:if)
          | k(:unless)|k(:while)|k(:until);

  def self.main(args:String[]) {
      returns void
      parser = MirahParser.new
      BaseParser.tracing = true
      if args.length > 0
        stream = InputStream(FileInputStream.new(args[0]))
      else
        stream = System.in
      end
      reader = BufferedReader.new(InputStreamReader.new(stream))
      buffer = char[8192]
      builder = StringBuilder.new
      while (read = reader.read(buffer, 0, buffer.length)) > 0
        builder.append(buffer, 0, read);
      end
      puts BaseParser.print_r(parser.parse(builder.toString()))
  }

  def initialize {
    @BEG = 0
    @begchars = "([{,;=" #}
    @HEX = "0123456789abcdefABCDEF"
    @DECIMAL = "0123456789"
    @OCTAL = "01234567"
    @BINARY = "01"
    @heredocs = LinkedList.new
    @memo = {}
    @nil = Ast.new('Nil')
    @nil.start_position = @nil.end_position = Position.new(0, 0, 0)
    @lhs_map = {
      "ConstAssign" => "Constant",
      "LocalAssign" => "Local",
      "InstVarAssign" => "InstVar",
      "ClassVarAssign" => "ClassVar",
    }
  }

  def oneOf() {
    chars = String(_pop)
    _char(chars)
  }

  def _codepoint() {
    t = _any
    return -1 if t == __ERROR__
    character = Character(t).charValue
    if character >= 0xd800 && character <= 0xdbff
      t = _any
      if t == __ERROR__
        return -1
      end
      return Character.toCodePoint(character, Character(t).charValue)
    else
      return int(character)
    end
  }

  def codepoint {
    start = _pos
    t = _codepoint
    if t == -1
      self._pos = start
      return Object(__ERROR__)
    else
      return Object(String.new(Character.toChars(t)))
    end
  }

  def identifierChar() {
    start = _pos
    c = _codepoint
    if c == 95 || Character.isLetterOrDigit(c)
      Object(String.new(Character.toChars(c)))
    else
      self._pos = start
      __ERROR__
    end
  }

  def upperCase {
    start = _pos
    c = _codepoint
    if Character.isUpperCase(c)
      Object(String.new(Character.toChars(c)))
    else
      self._pos = start
      __ERROR__
    end
  }

  def heredoc {
    # Note: This won't parse if we backtrack over the newline and not
    # the heredoc identifier. However the nl rule should be memoized
    # so we should be safe.

    # Set up a new list so nested heredocs match properly.
    heredocs = @heredocs
    @heredocs = LinkedList.new

    while heredocs.size > 0
      context = HeredocContext(heredocs.removeFirst)
      _push(context)
      node = context.node
      node.children.clear
      _t = if context.type == '"'
        dquote_heredoc
      else
        squote_heredoc
      end
      if _t == __ERROR__
        raise SyntaxError.new("Missing heredoc terminator #{context.id}.", _pos, _string, _list)
      elsif _t.kind_of?(String)
        node.name = 'String'
        node.add(_t)
      else
        l = List(_t)
        if l.size == 0
          node.name = 'String'
          node.add("")
        elsif l.size == 1 && Ast(l.get(0)).name.equals('String')
          node.name = 'String'
          node.addAll(Ast(l.get(0)).children)
        else
          node.name = 'DString'
          node.addAll(l)
        end
      end
    end
    "\n"
  }

  # Give a better error message than the default
  # k keyword=_   : . str(keyword) ~identifierChar {keyword};
  def k {
    keyword = String(_any)
    start = _pos
    ws
    t = _str(keyword)
    if t != __ERROR__
      t = __ERROR__ unless identifierChar == __ERROR__
    end
    if t == __ERROR__
      __ERROR__.last = keyword
      self._pos = start
    end
    t
  }

  def parseInt(string:string, radix:int) {
    Integer.valueOf(Integer.parseInt(string, radix))
  }

  def stringConcat(strings:Object) {
    result = nil
    List(strings).each do |s|
      result = stringConcat(result, s)
    end
    return result
  }

  def stringConcat(a:Object, b:Object) {
    la = Ast(a)
    lb = Ast(b)
    return la if lb.nil?
    return lb if la.nil?
    result = Ast.new("DString")
    [la, lb].each do |n|
      node = Ast(n)
      if node.name.equals("DString")
        result.addAll(node.children)
      else
        result.add(node)
      end
    end
    result.start_position = la.start_position
    result.end_position = lb.end_position
    result
  }

  def getCodePoint(c:Object) {
    String(c).codePointAt(0)
  }

  def obj2ast(x:Object) {
    if x.kind_of?(Ast)
      Ast(x)
    elsif x.kind_of?(List)
      l = List(x)
      if l.size == 0
        Ast(nil)
      elsif l.size == 1
        obj2ast(l.get(0))
      else
        ast = Ast.new('Body', l)
        first = obj2ast(l.get(0))
        last = obj2ast(l.get(l.size - 1))
        ast.start_position = first.start_position
        ast.end_position = last.end_position
        ast
      end
    elsif x.nil?
      Ast(nil)
    else
      raise "Expected Ast, got #{x} (#{x.getClass})"
    end
  }

  def addToBlock(a:Object, b:Object) {
    x = obj2ast(a)
    y = obj2ast(b)
    if x.nil?
      return y
    elsif y.nil?
      return x
    end
    x_kids = 'Body'.equals(x.name) ? x.children : [x]
    y_kids = 'Body'.equals(y.name) ? y.children : [y]
    body = Ast.new('Body', x_kids)
    body.addAll(y_kids)
    body.start_position = x.start_position
    body.end_position = y.end_position
    body
  }

  def checkExpression(e:Object) {
    # TODO actually check
    e || @nil
  }

  def gettable2(e:Object) {
    n = Ast(e)
    n2 = Ast(n.clone)
    n2.name = String(@lhs_map.get(n.name))
    n2
  }
}